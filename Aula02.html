<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <link rel="stylesheet" href="css/bootstrap.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:ital,wght@0,100..700;1,100..700&display=swap"
    rel="stylesheet">
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="css/estilo.css">
  <link rel="stylesheet" href="css/prism.css">

  <title>Desenvolvimento Mobile - Aula 02</title>
</head>

<body>
  <div class="wrapper d-flex align-items-stretch">
    <nav id="sidebar">
      <div class="custom-menu">
        <button type="button" id="sidebarCollapse" class="btn btn-primary">
          <i class="fa fa-bars"></i>
          <span class="sr-only">Toggle Menu</span>
        </button>
      </div>
      <h1><a href="index.html" class="logo text-center">AULAS</a></h1>
      <ul class="list-unstyled components mb-5">
        <li>
          <a href="Aula01.html"><span class="mr-1"></span>01 - Introdu√ß√£o e Panorama Mobile</a>
        </li>
        <li class="active">
          <a href="Aula02.html"><span class="mr-0"></span>02 - Revis√£o de JavaScript e TypeScript</a>
        </li>
        <li>
          <a href="Aula03.html"><span class="mr-0"></span>03 - Come√ßando com React: Componentes, JSX e Hooks</a>
        </li>
        <li>
          <a href="Aula04.html"><span class="mr-0"></span>04 - Interfaces Visuais em React Native</a>
        </li>
        <li>
          <a href="Aula05.html"><span class="mr-0"></span>05 - Navega√ß√£o com React Navigation</a>
        </li>
        <li>
          <a href=""><span class="mr-0"></span>06 - Consumo de APIs REST</a>
        </li>
        <li>
          <a href=""><span class="mr-0"></span>07 - Armazenamento e Estado Global</a>
        </li>
        <li>
          <a href=""><span class="mr-0"></span>08 - Recursos Nativos (C√¢mera, Localiza√ß√£o)</a>
        </li>
        <li>
          <a href=""><span class="mr-0"></span>09 - Boas Pr√°ticas e Arquitetura</a>
        </li>
        <li>
          <a href=""><span class="mr-0"></span>10 - Build, Publica√ß√£o e Projeto Final</a>
        </li>
      </ul>
    </nav>

    <div id="content" class="p-4 p-md-5 pt-5">
      <h1><strong>Aula 02 ‚Äì Revis√£o de JavaScript Moderno e Introdu√ß√£o ao TypeScript</strong></h1>
      <p>Ap√≥s nossa aula de abertura, em que exploramos a evolu√ß√£o do desenvolvimento mobile, as vantagens do React
        Native e o ecossistema oferecido pelo Expo, nesta segunda aula daremos in√≠cio √† base t√©cnica sobre a qual
        construiremos nossas aplica√ß√µes: a linguagem JavaScript moderna e o TypeScript!</p>
      <p>O JavaScript √© a linguagem principal do React Native. Seu dom√≠nio √© fundamental para compreender o
        funcionamento de componentes, o gerenciamento de estado, a manipula√ß√£o de dados e a intera√ß√£o com APIs.
        Entretanto, o JavaScript evoluiu significativamente ao longo dos anos. Muitas das pr√°ticas e sintaxes mais
        utilizadas hoje surgiram com o padr√£o ECMAScript 2015 (ES6) e vers√µes posteriores ‚Äî e s√£o essas que abordaremos
        aqui, pois vale a pena relembrar esses conceitos antes de mergulharmos no TypeScript, que ser√° nossa linguagem
        principal no desenvolvimento de apps.</p>
      <p>TypeScript √© um superconjunto de JavaScript que adiciona tipagem est√°tica ao c√≥digo, proporcionando maior
        seguran√ßa, clareza e produtividade. Por isso, esta aula tamb√©m servir√° como uma introdu√ß√£o pr√°tica e gradual ao
        TypeScript, com foco em seus recursos fundamentais e na transi√ß√£o natural a partir do JavaScript moderno -
        justificamos sua ado√ß√£o e at√© propusemos alguns exerc√≠cios sobre ele na aula anterior, lembram-se? üßë‚Äçüíª</p>
      <p>O objetivo √© garantir que todos estejam alinhados em rela√ß√£o aos conceitos, sintaxes e padr√µes essenciais de
        ambas as linguagens, criando uma base para as pr√≥ximas aulas, nas quais iniciaremos a constru√ß√£o de telas e
        funcionalidades reais com React Native.</p>
      <p>Vamos come√ßar com a revis√£o dos principais recursos modernos do JavaScript.</p>
      <h2><strong>1. Revis√£o de JavaScript Moderno (ES6+)</strong></h2>
      <h2>1.1 Declara√ß√£o de Vari√°veis: <code>let</code>, <code>const</code> e Escopo</h2>
      <p>At√© a padroniza√ß√£o trazida pelo ECMAScript 2015 (ES6), a √∫nica forma de declarar vari√°veis em JavaScript era
        por meio da palavra-chave <code>var</code>. Essa forma de declara√ß√£o apresenta caracter√≠sticas que hoje s√£o
        consideradas problem√°ticas, principalmente pelo escopo limitado a fun√ß√µes e pelo comportamento conhecido como
        <strong>hoisting</strong>, que pode levar a resultados inesperados e dif√≠ceis de depurar. Com a evolu√ß√£o da
        linguagem e das aplica√ß√µes web e m√≥veis, tornou-se essencial adotar um modelo mais previs√≠vel e seguro. Foi
        nesse contexto que surgiram <code>let</code> e <code>const</code>, duas palavras-chave que oferecem controle
        mais rigoroso sobre escopo e mutabilidade, e que passaram a ser padr√£o no desenvolvimento moderno ‚Äî tanto em
        JavaScript quanto em TypeScript.</p>
      <h3>Escopo de fun√ß√£o e escopo de bloco</h3>
      <p>Vari√°veis declaradas com <code>var</code> t√™m <strong>escopo de fun√ß√£o</strong>, ou seja, s√£o vis√≠veis em toda
        a fun√ß√£o onde foram declaradas, mesmo que isso ocorra dentro de um bloco como <code>if</code>, <code>for</code>
        ou <code>while</code>. J√° <code>let</code> e <code>const</code> t√™m <strong>escopo de bloco</strong>, ficando
        vis√≠veis apenas dentro do bloco em que foram definidas. Essa mudan√ßa reduz a chance de conflitos de nomes e
        facilita a manuten√ß√£o do c√≥digo.</p>
      <pre><code class="language-javascript">function exemplo() {
      if (true) {
        var a = 1;
        let b = 2;
        const c = 3;
      }
    
      console.log(a); // 1
      console.log(b); // ReferenceError
      console.log(c); // ReferenceError
    }
    </code></pre>
      <p>No exemplo acima, <code>a</code> permanece acess√≠vel fora do bloco <code>if</code>, enquanto <code>b</code> e
        <code>c</code> n√£o, porque foram declaradas com escopo de bloco. Esse comportamento √© mais intuitivo e
        compat√≠vel com o que se espera ao declarar vari√°veis locais em linguagens como Java, C# ou Swift.</p>
      <h3>Hoisting e zona morta temporal</h3>
      <p><strong>Hoisting</strong> √© o comportamento do JavaScript que consiste em <strong>elevar as declara√ß√µes de
          vari√°veis para o topo do escopo onde foram definidas</strong>, antes mesmo da execu√ß√£o do c√≥digo. Esse
        processo ocorre durante a fase de compila√ß√£o da linguagem, e se aplica a vari√°veis (<code>var</code>,
        <code>let</code>, <code>const</code>), fun√ß√µes e classes ‚Äî embora com regras diferentes para cada caso.</p>
      <p>No caso de vari√°veis declaradas com <code>var</code>, o nome da vari√°vel √© elevado ao topo do escopo da fun√ß√£o
        (ou do escopo global, se fora de uma fun√ß√£o) e seu valor inicial √© definido como <code>undefined</code>. Isso
        permite que a vari√°vel seja acessada antes de sua linha de declara√ß√£o, embora ainda n√£o tenha recebido o valor
        atribu√≠do.</p>
      <pre><code class="language-javascript">function exemploVar() {
      console.log(nome); // undefined
      var nome = &quot;Jo√£o&quot;;
    }
    </code></pre>
      <p>Esse comportamento pode causar confus√£o, especialmente em fun√ß√µes longas ou mal estruturadas, pois a vari√°vel
        &quot;parece existir&quot; antes mesmo de ser declarada, o que pode levar a interpreta√ß√µes erradas sobre a ordem
        l√≥gica do c√≥digo.</p>
      <p>J√° no caso de <code>let</code> e <code>const</code>, embora tamb√©m sofram hoisting (ou seja, seus nomes s√£o
        registrados internamente no topo do escopo), o acesso a essas vari√°veis <strong>antes da linha de declara√ß√£o √©
          bloqueado</strong>. Isso ocorre porque elas permanecem em um estado especial chamado <strong>zona morta
          temporal</strong> (<em>temporal dead zone</em>), que se estende desde o in√≠cio do bloco at√© a linha em que a
        vari√°vel √© declarada. Qualquer tentativa de acessar a vari√°vel nesse per√≠odo resulta em erro.</p>
      <pre><code class="language-javascript">console.log(contador); // ReferenceError
    let contador = 1;
    </code></pre>
      <pre><code class="language-javascript">console.log(apiUrl); // ReferenceError
    const apiUrl = &quot;https://meuapp.dev&quot;;
    </code></pre>
      <p>Esse comportamento mais restritivo torna o c√≥digo mais seguro e previs√≠vel, e √© uma das raz√µes pelas quais
        <code>let</code> e <code>const</code> s√£o preferidos em JavaScript moderno e TypeScript.</p>
      <table>
        <thead>
          <tr>
            <th>Tipo</th>
            <th>Sofre hoisting?</th>
            <th>Pode ser acessado antes da declara√ß√£o?</th>
            <th>Valor antes da linha de declara√ß√£o</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><code>var</code></td>
            <td>Sim</td>
            <td>Sim</td>
            <td><code>undefined</code></td>
          </tr>
          <tr>
            <td><code>let</code></td>
            <td>Sim</td>
            <td>N√£o</td>
            <td>Erro (zona morta temporal)</td>
          </tr>
          <tr>
            <td><code>const</code></td>
            <td>Sim</td>
            <td>N√£o</td>
            <td>Erro (zona morta temporal)</td>
          </tr>
        </tbody>
      </table>
      <h3>Mutabilidade e const√¢ncia</h3>
      <p>Outro ponto importante √© a <strong>mutabilidade</strong>. Vari√°veis declaradas com <code>let</code> podem ter
        seus valores reatribu√≠dos, enquanto aquelas declaradas com <code>const</code> <strong>n√£o podem</strong>. Isso
        n√£o significa que <code>const</code> cria valores imut√°veis, mas sim que a refer√™ncia n√£o pode ser alterada.
        Quando se trata de objetos ou arrays, o conte√∫do interno ainda pode ser modificado.</p>
      <pre><code class="language-javascript">const usuario = { nome: &quot;Ana&quot; };
    usuario.nome = &quot;Maria&quot;; // permitido
    usuario = { nome: &quot;Jo√£o&quot; }; // erro
    
    const lista = [1, 2, 3];
    lista.push(4); // permitido
    lista = [10, 20]; // erro
    </code></pre>
      <p>Esse comportamento √© relevante para o React Native, onde frequentemente utilizamos <code>const</code> para
        definir estados e fun√ß√µes auxiliares, mesmo quando o conte√∫do pode ser atualizado por meio de mecanismos
        controlados, como o <code>useState</code>. üßë‚Äçüíª</p>
      <pre><code class="language-tsx">const [tarefas, setTarefas] = useState([&quot;Estudar&quot;]);
    </code></pre>
      <p>Nesse caso, a refer√™ncia ao estado (<code>tarefas</code>) permanece constante, e seu conte√∫do muda
        indiretamente via <code>setTarefas</code>.</p>
      <h3>Tipagem em TypeScript</h3>
      <p>No TypeScript, <code>let</code> e <code>const</code> seguem exatamente os mesmos comportamentos de escopo e
        hoisting do JavaScript moderno. A principal diferen√ßa est√° na <strong>tipagem est√°tica</strong>, que permite
        especificar os tipos das vari√°veis e obter verifica√ß√£o de erros durante o desenvolvimento.</p>
      <pre><code class="language-ts">let idade: number = 30;
    idade = &quot;trinta&quot;; // Erro: string n√£o √© atribu√≠vel a number
    </code></pre>
      <p>Ao usar <code>const</code>, o TypeScript √© capaz de inferir <strong>valores literais</strong> como tipos
        espec√≠ficos. Isso √© √∫til para restringir valores em enums simulados ou par√¢metros de configura√ß√£o.</p>
      <pre><code class="language-ts">const cor = &quot;azul&quot;; // Tipo: &quot;azul&quot;
    type CorPrimaria = &quot;vermelho&quot; | &quot;azul&quot; | &quot;amarelo&quot;;
    
    const escolhida: CorPrimaria = cor; // v√°lido
    const invalida: CorPrimaria = &quot;verde&quot;; // erro
    </code></pre>
      <p>Quando declaramos uma vari√°vel com <code>const</code>, estamos dizendo que ela ser√° <strong>uma
          constante</strong>: ou seja, <strong>n√£o ser√° poss√≠vel reatribuir outro valor a ela no futuro</strong>. Isso
        significa que se voc√™ escrever:</p>
      <pre><code class="language-ts">const status = &quot;ativo&quot;;
    </code></pre>
      <p>o valor <code>&quot;ativo&quot;</code> ser√° permanentemente associado a essa vari√°vel ‚Äî n√£o ser√° poss√≠vel
        fazer:</p>
      <pre><code class="language-ts">status = &quot;inativo&quot;; // ‚ùå Erro: n√£o √© permitido reatribuir uma constante
    </code></pre>
      <p>Portanto, nesse exemplo, <code>&quot;ativo&quot;</code> n√£o √© apenas uma string qualquer: √© <strong>um valor
          literal imut√°vel</strong> ligado a uma vari√°vel constante! No entanto, vale destacar um detalhe importante:
        quando usamos <code>const</code> com objetos ou arrays, o que se torna constante √© a <strong>refer√™ncia</strong>
        ao objeto ‚Äî mas o conte√∫do interno ainda pode ser alterado.</p>
      <pre><code class="language-ts">const usuario = { nome: &quot;Ana&quot; };
    usuario.nome = &quot;Maria&quot;; // ‚úÖ permitido (estamos mudando o conte√∫do)
    usuario = { nome: &quot;Jo√£o&quot; }; // ‚ùå erro (n√£o podemos trocar o objeto)
    </code></pre>
      <p>Esse comportamento √© consistente com outras linguagens que utilizam o conceito de refer√™ncia. O que o
        <code>const</code> garante √© que <strong>a vari√°vel n√£o apontar√° para outro valor</strong> ‚Äî mas se o valor for
        um objeto mut√°vel, ainda ser√° poss√≠vel alter√°-lo internamente.</p>
      <p>Essa defini√ß√£o √© essencial quando combinamos <code>const</code> com os tipos literais do TypeScript, pois a
        combina√ß√£o entre <strong>const√¢ncia de valor</strong> e <strong>tipagem literal</strong> permite definir regras
        muito precisas de quais valores s√£o aceitos e impedir mudan√ßas acidentais ao longo do c√≥digo.</p>
      <p>Esse recurso contribui para uma codifica√ß√£o mais segura e facilita a detec√ß√£o precoce de erros, especialmente
        em projetos grandes ou com m√∫ltiplos m√≥dulos.</p>
      <h3>Diretrizes de uso</h3>
      <p>A pr√°tica mais comum e recomendada √© declarar vari√°veis com <code>const</code> sempre que n√£o houver
        necessidade de reatribui√ß√£o. Isso torna o c√≥digo mais previs√≠vel e explicita a inten√ß√£o do desenvolvedor. Use
        <code>let</code> apenas quando for necess√°rio alterar o valor da vari√°vel ao longo do tempo, como em contadores
        ou ac√∫mulos. O uso de <code>var</code> deve ser evitado completamente.</p>
      <p>Al√©m disso, √© importante declarar vari√°veis no escopo mais restrito poss√≠vel, para evitar conflitos de nomes e
        facilitar a manuten√ß√£o. Em projetos com TypeScript, recomenda-se tipar explicitamente vari√°veis exportadas,
        par√¢metros de fun√ß√£o e objetos mais complexos, mesmo quando o compilador pode inferir os tipos automaticamente.
      </p>
      <p>O dom√≠nio desses conceitos √© essencial para escrever c√≥digo limpo, especialmente no contexto do desenvolvimento
        mobile com React Native, onde a gest√£o do estado, a composi√ß√£o de componentes e a previsibilidade de escopo s√£o
        fundamentais. O uso consciente de <code>let</code>, <code>const</code> e da tipagem em TypeScript forma a base
        sobre a qual construiremos aplica√ß√µes m√≥veis confi√°veis e f√°ceis de manter. ‚úçÔ∏è</p>
      <hr>
      <h2>1.2 Fun√ß√µes An√¥nimas e Arrow Functions</h2>
      <p>Em JavaScript, fun√ß√µes podem ser declaradas de diversas formas. Duas delas merecem aten√ß√£o especial:
        <strong>fun√ß√µes an√¥nimas</strong> e <strong>arrow functions</strong>. Ambas s√£o muito utilizadas no
        desenvolvimento com React e React Native, especialmente para definir manipuladores de eventos, fun√ß√µes
        auxiliares dentro de componentes, ou par√¢metros de m√©todos como <code>map</code>, <code>filter</code>,
        <code>setTimeout</code>, entre outros.</p>
      <h3>Fun√ß√µes an√¥nimas: defini√ß√£o e uso</h3>
      <p>Uma fun√ß√£o an√¥nima √© simplesmente uma fun√ß√£o <strong>sem nome</strong>, atribu√≠da geralmente a uma vari√°vel ou
        passada como argumento para outra fun√ß√£o. Seu uso √© comum em situa√ß√µes onde a fun√ß√£o ser√° usada apenas naquele
        contexto espec√≠fico.</p>
      <pre><code class="language-javascript">const saudacao = function(nome) {
      return `Ol√°, ${nome}!`;
    };
    
    console.log(saudacao(&quot;Maria&quot;)); // &quot;Ol√°, Maria!&quot;
    </code></pre>
      <p>Essa sintaxe √© perfeitamente v√°lida e ainda bastante usada. Por√©m, com a chegada do ES6, foi introduzida uma
        nova forma de declarar fun√ß√µes: as <strong>arrow functions</strong>, que se tornaram o padr√£o moderno,
        principalmente em c√≥digo React.</p>
      <h3>Arrow functions: sintaxe e vantagens</h3>
      <p>As <strong>arrow functions</strong> s√£o uma forma mais concisa de escrever fun√ß√µes an√¥nimas, utilizando a seta
        <code>=&gt;</code> para indicar a rela√ß√£o entre os par√¢metros e o corpo da fun√ß√£o. Veja a reescrita da fun√ß√£o
        anterior como arrow function:</p>
      <pre><code class="language-javascript">const saudacao = (nome) =&gt; {
      return `Ol√°, ${nome}!`;
    };
    </code></pre>
      <p>Quando a fun√ß√£o tem apenas <strong>um par√¢metro</strong> e <strong>retorna uma √∫nica express√£o</strong>,
        podemos omitir os par√™nteses e a palavra <code>return</code>:</p>
      <pre><code class="language-javascript">const saudacao = nome =&gt; `Ol√°, ${nome}!`;
    </code></pre>
      <p>Essa sintaxe compacta melhora a legibilidade, especialmente para fun√ß√µes curtas e sem l√≥gica interna complexa.
        Ela √© muito comum em chamadas de m√©todos de array:</p>
      <pre><code class="language-javascript">const nomes = [&quot;Ana&quot;, &quot;Carlos&quot;, &quot;Jo√£o&quot;];
    
    const cumprimentos = nomes.map(nome =&gt; `Ol√°, ${nome}!`);
    console.log(cumprimentos);
    // [&quot;Ol√°, Ana!&quot;, &quot;Ol√°, Carlos!&quot;, &quot;Ol√°, Jo√£o!&quot;]
    </code></pre>
      <h3>Diferen√ßa fundamental: o <code>this</code></h3>
      <p>Apesar da sintaxe mais curta, h√° uma diferen√ßa sem√¢ntica importante entre fun√ß√µes tradicionais e arrow
        functions: <strong>o comportamento da palavra-chave <code>this</code></strong>.</p>
      <p>Fun√ß√µes tradicionais definem seu <strong>pr√≥prio contexto de <code>this</code></strong> no momento em que s√£o
        chamadas. J√° arrow functions <strong>n√£o criam um novo <code>this</code></strong> ‚Äî elas <strong>herdam o
          <code>this</code> do escopo em que foram definidas</strong>. Isso √© √∫til em muitos cen√°rios, especialmente no
        React, pois evita a necessidade de fazer <em>bind</em> manual do contexto.</p>
      <p>Veja a diferen√ßa:</p>
      <pre><code class="language-javascript">const obj = {
      nome: &quot;Maria&quot;,
      saudacaoTradicional: function() {
        return `Ol√°, meu nome √© ${this.nome}`;
      },
      saudacaoArrow: () =&gt; {
        return `Ol√°, meu nome √© ${this.nome}`;
      }
    };
    
    console.log(obj.saudacaoTradicional()); // &quot;Ol√°, meu nome √© Maria&quot;
    console.log(obj.saudacaoArrow());       // &quot;Ol√°, meu nome √© undefined&quot;
    </code></pre>
      <p>No exemplo acima, <code>saudacaoTradicional</code> funciona corretamente porque o <code>this</code> se refere
        ao objeto <code>obj</code>. J√° <code>saudacaoArrow</code> falha porque a fun√ß√£o flecha foi criada no escopo
        global (ou de m√≥dulo) e, portanto, o <code>this</code> n√£o aponta para <code>obj</code>, mas sim para o escopo
        externo ‚Äî onde <code>this.nome</code> √© <code>undefined</code>.</p>
      <p>Por outro lado, <strong>h√° situa√ß√µes em que essa heran√ßa de contexto √© justamente o que queremos!</strong>. Em
        callbacks ass√≠ncronos, como em <code>setTimeout</code>, <code>map</code>, ou manipuladores dentro de m√©todos de
        classes, as arrow functions funcionam bem por manterem o <code>this</code> do contexto externo:</p>
      <pre><code class="language-javascript">function Pessoa(nome) {
      this.nome = nome;
    
      this.apresentar = function() {
        setTimeout(() =&gt; {
          console.log(`Ol√°, meu nome √© ${this.nome}`);
        }, 1000);
      };
    }
    
    const maria = new Pessoa(&quot;Maria&quot;);
    maria.apresentar(); // Ap√≥s 1 segundo: &quot;Ol√°, meu nome √© Maria&quot;
    </code></pre>
      <p>Se us√°ssemos uma fun√ß√£o tradicional dentro de <code>setTimeout</code>, o <code>this</code> deixaria de apontar
        para a inst√¢ncia <code>Pessoa</code>, e o c√≥digo n√£o funcionaria como esperado. Esse comportamento previs√≠vel do
        <code>this</code> nas arrow functions √© uma das raz√µes pelas quais elas s√£o muito utilizadas em componentes
        funcionais e hooks no React. üë®‚Äçüè≠</p>
      <h3><strong>Arrow functions com tipos expl√≠citos</strong></h3>
      <p>Em TypeScript, voc√™ pode (e deve) declarar os tipos de <strong>par√¢metros</strong> e do <strong>valor de
          retorno</strong> de fun√ß√µes arrow. Isso garante que a fun√ß√£o seja usada corretamente em diferentes contextos.
      </p>
      <pre><code class="language-ts">const soma = (a: number, b: number): number =&gt; {
      return a + b;
    };
    </code></pre>
      <p>Se o retorno for inferido corretamente e for simples, o TypeScript permite omitir a anota√ß√£o, mas em fun√ß√µes
        reutiliz√°veis ou exportadas, √© uma boa pr√°tica <strong>tipar explicitamente</strong> o retorno. ‚úçÔ∏è</p>
      <h3><strong>Arrow functions e gen√©ricos</strong></h3>
      <p>Arrow functions tamb√©m podem ser gen√©ricas ‚Äî √∫teis, por exemplo, em fun√ß√µes utilit√°rias:</p>
      <pre><code class="language-ts">const primeiroElemento = &lt;T&gt;(lista: T[]): T =&gt; lista[0];
    
    const nomes = [&quot;Ana&quot;, &quot;Carlos&quot;];
    const primeiro = primeiroElemento(nomes); // tipo inferido: string
    </code></pre>
      <p>Isso mostra a <strong>versatilidade de fun√ß√µes flecha em c√≥digo tipado</strong>, e ajuda a conectar conceitos
        que ser√£o aprofundados em t√≥picos posteriores da aula. </p>
      <h3>Aplica√ß√µes pr√°ticas no React Native</h3>
      <p>Em componentes funcionais com React Native, o uso de arrow functions √© muito frequente. Elas s√£o utilizadas
        tanto na defini√ß√£o de handlers como em callbacks passados para componentes filhos:</p>
      <pre><code class="language-tsx">const MeuBotao = () =&gt; {
      const handlePress = () =&gt; {
        console.log(&quot;Bot√£o pressionado&quot;);
      };
    
      return &lt;Button title=&quot;Clique&quot; onPress={handlePress} /&gt;;
    };
    </code></pre>
      <p>Como alternativa, podemos usar a arrow function diretamente no JSX ‚Äî o que √© √∫til para casos simples, mas deve
        ser feito com cautela para n√£o gerar fun√ß√µes novas a cada renderiza√ß√£o:</p>
      <pre><code class="language-tsx">&lt;Button title=&quot;Clique&quot; onPress={() =&gt; console.log(&quot;Bot√£o pressionado&quot;)} /&gt;
    </code></pre>
      <h3>Ou seja...</h3>
      <p>Arrow functions s√£o uma evolu√ß√£o das fun√ß√µes an√¥nimas tradicionais. Elas oferecem uma sintaxe mais curta e uma
        sem√¢ntica de <code>this</code> mais previs√≠vel no contexto de componentes e fun√ß√µes de ordem superior. Entender
        suas diferen√ßas √© importante para escrever c√≥digo limpo, leg√≠vel e compat√≠vel com os padr√µes modernos do
        JavaScript e do ecossistema React. ü§ì</p>
      <hr>
      <h2>1.3 Template Literals: interpola√ß√£o e multilinha com crases</h2>
      <p>At√© o ES6, a √∫nica forma de compor strings em JavaScript era utilizando aspas simples ou duplas, combinadas com
        o operador de concatena√ß√£o (<code>+</code>). Embora funcional, essa abordagem rapidamente se tornava inc√¥moda e
        dif√≠cil de ler, especialmente ao lidar com m√∫ltiplas vari√°veis ou quebras de linha.</p>
      <p>Com a introdu√ß√£o dos <strong>template literals</strong> (ou <strong>template strings</strong>) no ECMAScript
        2015, tornou-se poss√≠vel construir strings <strong>de forma mais clara e expressiva</strong>, utilizando a crase
        (```) no lugar das aspas.</p>
      <h3>Interpola√ß√£o de vari√°veis</h3>
      <p>Uma das principais vantagens dos template literals √© a <strong>interpola√ß√£o de express√µes</strong>, que permite
        inserir valores diretamente dentro da string usando <code>${...}</code>.</p>
      <p>Antes do ES6:</p>
      <pre><code class="language-javascript">const nome = &quot;Jo√£o&quot;;
    const idade = 30;
    const mensagem = &quot;Ol√°, meu nome √© &quot; + nome + &quot; e eu tenho &quot; + idade + &quot; anos.&quot;;
    </code></pre>
      <p>Com template literals:</p>
      <pre><code class="language-javascript">const nome = &quot;Jo√£o&quot;;
    const idade = 30;
    const mensagem = `Ol√°, meu nome √© ${nome} e eu tenho ${idade} anos.`;
    </code></pre>
      <p>Al√©m de mais leg√≠vel, essa forma √© menos propensa a erros de concatena√ß√£o e facilita a leitura do c√≥digo ‚Äî algo
        especialmente importante em interfaces com textos din√¢micos, como labels, notifica√ß√µes ou mensagens formatadas
        em aplicativos React Native.</p>
      <h3>Avalia√ß√£o de express√µes</h3>
      <p>√â poss√≠vel interpolar n√£o apenas vari√°veis, mas <strong>qualquer express√£o v√°lida em JavaScript</strong>, como
        chamadas de fun√ß√£o, operadores tern√°rios, opera√ß√µes matem√°ticas, entre outras.</p>
      <pre><code class="language-javascript">const a = 5;
    const b = 3;
    const resultado = `A soma de ${a} + ${b} √© ${a + b}`;
    // &quot;A soma de 5 + 3 √© 8&quot;
    </code></pre>
      <p>Ou, em casos mais elaborados:</p>
      <pre><code class="language-javascript">const nome = &quot;Lucas&quot;;
    const status = true;
    const saudacao = `Bem-vindo, ${nome}. Status: ${status ? &quot;ativo&quot; : &quot;inativo&quot;}.`;
    // &quot;Bem-vindo, Lucas. Status: ativo.&quot;
    </code></pre>
      <p>Esse recurso reduz a necessidade de criar vari√°veis intermedi√°rias apenas para compor mensagens, tornando o
        c√≥digo mais direto e funcional. ü§©</p>
      <h3>Strings multilinha</h3>
      <p>Outro benef√≠cio importante √© a possibilidade de escrever <strong>strings com m√∫ltiplas linhas</strong> sem a
        necessidade de caracteres especiais (<code>\n</code>) ou concatena√ß√£o entre linhas.</p>
      <p>Antes do ES6:</p>
      <pre><code class="language-javascript">const mensagem = &quot;Linha 1\n&quot; +
                     &quot;Linha 2\n&quot; +
                     &quot;Linha 3&quot;;
    </code></pre>
      <p>Com template literals:</p>
      <pre><code class="language-javascript">const mensagem = `Linha 1
    Linha 2
    Linha 3`;
    </code></pre>
      <p>Esse recurso √© √∫til para exibir mensagens com quebras de linha, gerar trechos de c√≥digo, construir templates
        HTML ou armazenar textos longos que precisam manter a formata√ß√£o original ‚Äî tudo de forma nativa e sem
        necessidade de escapes.</p>
      <h3>Aplica√ß√µes no React Native</h3>
      <p>No desenvolvimento de interfaces m√≥veis com React Native, o uso de template literals aparece frequentemente em:
      </p>
      <ul>
        <li>Mensagens din√¢micas (<code>Toast</code>, <code>Alert</code>, <code>Text</code>)</li>
        <li>Formata√ß√£o de dados (como unidades, valores ou nomes)</li>
        <li>Logs e depura√ß√£o</li>
        <li>Constru√ß√£o de strings de requisi√ß√£o para APIs</li>
      </ul>
      <p>Exemplo:</p>
      <pre><code class="language-tsx">const usuario = &quot;Camila&quot;;
    const saldo = 25.5;
    
    &lt;Text&gt;{`Ol√°, ${usuario}. Seu saldo atual √© R$ ${saldo.toFixed(2)}`}&lt;/Text&gt;
    </code></pre>
      <p>Neste caso, o uso de template literals evita concatena√ß√£o manual e garante melhor leitura, al√©m de manter o JSX
        limpo e expressivo! üòä</p>
      <h3>Template Literals em TypeScript</h3>
      <p>A partir do TypeScript 4.1, √© poss√≠vel criar <strong>tipos compostos dinamicamente</strong> com base em strings
        ‚Äî algo especialmente √∫til para representar <strong>valores formatados, nomes compostos ou chaves de
          objetos</strong>.</p>
      <pre><code class="language-ts">type Status = &quot;ativo&quot; | &quot;inativo&quot;;
    type Mensagem = `Usu√°rio est√° ${Status}`;
    
    const m1: Mensagem = &quot;Usu√°rio est√° ativo&quot;;   // ‚úÖ v√°lido
    const m2: Mensagem = &quot;Usu√°rio est√° ocupado&quot;; // ‚ùå erro: n√£o √© um Status conhecido
    </code></pre>
      <h3><strong>Aplica√ß√£o pr√°tica: composi√ß√£o de nomes ou chaves</strong></h3>
      <pre><code class="language-ts">type NomeCampo = &quot;nome&quot; | &quot;email&quot; | &quot;idade&quot;;
    type EventoCampo = `onChange${Capitalize&lt;NomeCampo&gt;}`;
    
    const evento: EventoCampo = &quot;onChangeEmail&quot;; // v√°lido
    </code></pre>
      <p>Esse recurso se conecta diretamente com padr√µes usados em formul√°rios, eventos, mensagens e APIs que seguem
        conven√ß√µes de nomenclatura. Ele mostra como <strong>o uso de template literals pode ser levado para o sistema de
          tipos</strong>, oferecendo seguran√ßa adicional e <strong>evitando erros de strings ‚Äúm√°gicas‚Äù</strong>
        espalhadas pelo c√≥digo.</p>
      <h3>Em suma!</h3>
      <p>Template literals representam uma evolu√ß√£o significativa na forma de lidar com strings em JavaScript. Eles
        tornam o c√≥digo mais leg√≠vel, expressivo e menos sujeito a erros, al√©m de oferecer suporte nativo para
        interpola√ß√£o de valores e strings multilinha. Seu uso √© amplamente adotado no desenvolvimento moderno,
        especialmente quando se trabalha com interfaces din√¢micas e comunica√ß√£o textual em aplica√ß√µes React Native.</p>
      <hr>
      <h2>1.4 Desestrutura√ß√£o de Arrays</h2>
      <p>A <strong>desestrutura√ß√£o</strong> (ou <em>destructuring</em>) √© um recurso introduzido no ES6 que permite
        extrair valores de arrays ou propriedades de objetos diretamente em vari√°veis, usando uma sintaxe concisa e
        leg√≠vel. No caso dos <strong>arrays</strong>, a desestrutura√ß√£o √© √∫til quando queremos extrair <strong>valores
          por posi√ß√£o</strong>, sem precisar acessar manualmente cada √≠ndice.</p>
      <p>Antes do ES6, extrair valores de um array envolvia chamadas expl√≠citas:</p>
      <pre><code class="language-javascript">const coordenadas = [10, 20];
    const x = coordenadas[0];
    const y = coordenadas[1];
    </code></pre>
      <p>Com a desestrutura√ß√£o de arrays, o c√≥digo se torna mais direto:</p>
      <pre><code class="language-javascript">const coordenadas = [10, 20];
    const [x, y] = coordenadas;
    
    console.log(x); // 10
    console.log(y); // 20
    </code></pre>
      <p>O lado esquerdo da atribui√ß√£o define <strong>vari√°veis posicionais</strong> e o lado direito deve ser um array
        (ou valor iter√°vel compat√≠vel). A ordem importa: o primeiro item do array ser√° atribu√≠do √† primeira vari√°vel, o
        segundo √† segunda, e assim por diante.</p>
      <h3>Pulos de elementos</h3>
      <p>√â poss√≠vel ‚Äúpular‚Äù elementos do array deixando espa√ßos vazios entre as v√≠rgulas:</p>
      <pre><code class="language-javascript">const cores = [&quot;vermelho&quot;, &quot;verde&quot;, &quot;azul&quot;];
    const [, , terceira] = cores;
    
    console.log(terceira); // &quot;azul&quot;
    </code></pre>
      <p>Nesse exemplo, apenas o terceiro elemento foi extra√≠do ‚Äî os dois primeiros foram ignorados.</p>
      <h3>Desestrutura√ß√£o com valores padr√£o</h3>
      <p>Em JavaScript, ao fazer desestrutura√ß√£o de arrays, podemos atribuir <strong>valores padr√£o</strong> √†s
        vari√°veis. Isso significa que, <strong>caso o valor correspondente esteja ausente ou
          <code>undefined</code></strong>, o valor padr√£o ser√° utilizado no lugar.</p>
      <p>A sintaxe √© simples: basta adicionar o sinal de igual (<code>=</code>) ap√≥s o nome da vari√°vel, dentro do
        padr√£o de desestrutura√ß√£o.</p>
      <pre><code class="language-javascript">const dados = [42];
    const [numero, outro = 0] = dados;
    
    console.log(numero); // 42
    console.log(outro);  // 0 (valor padr√£o)
    </code></pre>
      <p>Neste exemplo:</p>
      <ul>
        <li><code>dados</code> √© um array com apenas um elemento: o n√∫mero <code>42</code>;</li>
        <li><code>numero</code> recebe o primeiro valor do array, ou seja, <code>42</code>;</li>
        <li><code>outro</code> tenta receber o <strong>segundo valor</strong> do array ‚Äî mas como ele n√£o existe (est√°
          <code>undefined</code>), assume o <strong>valor padr√£o <code>0</code></strong>.</li>
      </ul>
      <p>A sintaxe <code>[numero, outro = 0]</code> indica: <em>&quot;pegue o segundo valor do array; se ele estiver
          ausente ou for <code>undefined</code>, use <code>0</code> como valor alternativo&quot;</em>.</p>
      <p>Esse padr√£o √© muito √∫til em situa√ß√µes como:</p>
      <ul>
        <li>Valores opcionais retornados por uma fun√ß√£o;</li>
        <li>Arrays que v√™m de fontes externas (ex: APIs);</li>
        <li>Par√¢metros de fun√ß√£o que usam desestrutura√ß√£o de arrays.</li>
      </ul>
      <p>Outro exemplo com mais elementos:</p>
      <pre><code class="language-javascript">const resposta = [undefined, 200];
    const [mensagem = &quot;Erro desconhecido&quot;, codigo] = resposta;
    
    console.log(mensagem); // &quot;Erro desconhecido&quot;
    console.log(codigo);   // 200
    </code></pre>
      <p>Nesse caso, a vari√°vel <code>mensagem</code> recebe o valor <code>&quot;Erro desconhecido&quot;</code> porque o
        primeiro elemento do array √© <code>undefined</code>.</p>
      <p>Esse recurso evita a necessidade de condicionais adicionais (<code>if</code> ou <code>?:</code>) para verificar
        valores ausentes, tornando o c√≥digo mais limpo e simples de escrevermos. üòÅ</p>
      <h3>Uso em fun√ß√µes</h3>
      <p>A desestrutura√ß√£o pode ser usada diretamente nos <strong>par√¢metros de uma fun√ß√£o</strong> ‚Äî algo bastante
        comum em React Native, especialmente em hooks ou componentes funcionais.</p>
      <pre><code class="language-javascript">function imprimirCoordenadas([x, y]) {
      console.log(`X: ${x}, Y: ${y}`);
    }
    
    imprimirCoordenadas([12, 8]); // &quot;X: 12, Y: 8&quot;
    </code></pre>
      <p>Com essa sintaxe, evitamos a cria√ß√£o de vari√°veis intermedi√°rias dentro da fun√ß√£o.</p>
      <h3>Aplica√ß√µes pr√°ticas no React Native</h3>
      <p>A desestrutura√ß√£o de arrays aparece com frequ√™ncia no uso de hooks. O exemplo mais comum √© o
        <code>useState</code>:</p>
      <pre><code class="language-tsx">const [contador, setContador] = useState(0);
    </code></pre>
      <p>Nesse caso, <code>useState</code> retorna um array com dois elementos: o valor atual e a fun√ß√£o que o atualiza.
        A desestrutura√ß√£o permite nome√°-los diretamente, o que melhora a clareza e evita o uso de √≠ndices num√©ricos
        (<code>[0]</code>, <code>[1]</code>).</p>
      <p>Outro uso comum √© em <strong>retornos m√∫ltiplos</strong> de fun√ß√µes utilit√°rias:</p>
      <pre><code class="language-ts">function useData(): [boolean, string] {
      return [true, &quot;dados carregados&quot;];
    }
    
    const [carregando, mensagem] = useData();
    </code></pre>
      <p>Nesse exemplo, usamos TypeScript para tipar os elementos do array retornado. A desestrutura√ß√£o continua
        funcionando normalmente e, com os tipos definidos, o editor pode fornecer autocompletar e alertar sobre
        poss√≠veis erros.</p>
      <h3>Considera√ß√µes sobre TypeScript na desestrutura√ß√£o de arrays</h3>
      <h4><strong>TypeScript infere os tipos dos elementos desestruturados</strong></h4>
      <p>Se uma fun√ß√£o retorna um array com tipos conhecidos, o TypeScript consegue inferir os tipos corretos ao fazer a
        desestrutura√ß√£o ‚Äî e isso vale tanto para arrays simples quanto para retornos de hooks ou utilit√°rios
        personalizados.</p>
      <pre><code class="language-ts">function useStatus(): [boolean, string] {
      return [true, &quot;Carregando&quot;];
    }
    
    const [ativo, mensagem] = useStatus();
    // ativo: boolean
    // mensagem: string
    </code></pre>
      <p>Mesmo que voc√™ n√£o escreva os tipos explicitamente durante a desestrutura√ß√£o, o TypeScript entende o tipo de
        cada posi√ß√£o com base na assinatura da fun√ß√£o.</p>
      <h4><strong>Voc√™ tamb√©m pode tipar os itens desestruturados manualmente!</strong></h4>
      <p>Caso esteja lidando com dados de origem externa (como uma API) ou queira ser expl√≠cito, √© poss√≠vel declarar os
        tipos das vari√°veis desestruturadas individualmente:</p>
      <pre><code class="language-ts">const dados: [number, string, boolean] = [1, &quot;ok&quot;, true];
    const [id, status, visivel]: [number, string, boolean] = dados;
    </code></pre>
      <p>Essa forma √© √∫til quando a fonte de dados n√£o tem tipos confi√°veis ou quando se quer refor√ßar o contrato com
        outras partes do sistema.</p>
      <h4><strong>Desestrutura√ß√£o como par√¢metro de fun√ß√£o tamb√©m pode ser tipada!</strong></h4>
      <p>Voc√™ pode tipar os elementos desestruturados diretamente nos par√¢metros de uma fun√ß√£o:</p>
      <pre><code class="language-ts">function logCoordenadas([x, y]: [number, number]): void {
      console.log(`X: ${x}, Y: ${y}`);
    }
    </code></pre>
      <p>Esse formato √© claro, direto e evita a cria√ß√£o de tipos intermedi√°rios quando a estrutura de dados √© simples.
      </p>
      <h4><strong>Cuidados com arrays heterog√™neos‚ÄºÔ∏è</strong></h4>
      <p>Ao desestruturar arrays com m√∫ltiplos tipos (ex: <code>[string, number]</code>), evite tratar o resultado como
        <code>any[]</code> ou <code>Array&lt;any&gt;</code>. Sempre prefira <strong>tuplas tipadas</strong>
        (<code>[string, number]</code>), para que o TypeScript possa <strong>validar a ordem e o tipo de cada item
          individualmente</strong>.</p>
      <pre><code class="language-ts">const tupla: [string, number] = [&quot;idade&quot;, 30];
    const [rotulo, valor] = tupla;
    
    // rotulo: string, valor: number
    </code></pre>
      <p>Isso previne erros como acessar <code>valor.toUpperCase()</code> ou somar <code>rotulo + 1</code>, que
        passariam despercebidos se os itens fossem inferidos apenas como <code>any</code>.</p>
      <h4>T√° bom, mas por que preciso saber disso?</h4>
      <p>Esses conceitos tornam-se relevantes quando consideramos o papel da desestrutura√ß√£o no desenvolvimento com
        React Native e TypeScript. A capacidade do TypeScript de <strong>inferir automaticamente os tipos</strong> dos
        elementos desestruturados contribui para uma experi√™ncia de desenvolvimento mais fluida: o editor fornece
        autocompletar, verifica tipos em tempo real e evita que erros comuns passem despercebidos. Ao mesmo tempo, a
        possibilidade de <strong>tipar manualmente os elementos desestruturados</strong> ‚Äî seja por clareza, por
        seguran√ßa ao lidar com dados externos, ou por necessidade de documenta√ß√£o ‚Äî permite explicitar contratos entre
        diferentes partes do sistema e refor√ßar a previsibilidade do c√≥digo.</p>
      <p>Tipar diretamente os par√¢metros em fun√ß√µes que utilizam desestrutura√ß√£o tamb√©m ajuda a evitar redund√¢ncias e
        torna o c√≥digo mais direto, especialmente em fun√ß√µes auxiliares ou callbacks simples. Al√©m disso, quando lidamos
        com <strong>arrays heterog√™neos</strong>, o uso de <strong>tuplas tipadas</strong> em vez de <code>any[]</code>
        √© uma pr√°tica fundamental para garantir a verifica√ß√£o precisa da ordem e do tipo de cada posi√ß√£o ‚Äî prevenindo
        erros sutis e promovendo uma maior robustez na manipula√ß√£o dos dados.</p>
      <p>Entender como o TypeScript lida com desestrutura√ß√£o em diferentes contextos √© importante para escrever c√≥digo
        expressivo e seguro. Esses recursos n√£o apenas melhoram a legibilidade e a manuten√ß√£o do c√≥digo, mas tamb√©m se
        alinham aos princ√≠pios da programa√ß√£o funcional e da tipagem est√°tica ‚Äî fundamentos que sustentam aplica√ß√µes
        modernas. </p>
      <h3>‚úÖ Conclus√£o pr√°tica</h3>
      <p>Em contextos como o React Native, onde muitos hooks e fun√ß√µes retornam arrays com m√∫ltiplos valores, esse
        recurso √© n√£o apenas √∫til, mas basilar para uma escrita fluida e moderna. A desestrutura√ß√£o continua funcionando
        em TypeScript exatamente como em JavaScript, mas ganha mais poder com a tipagem est√°tica.</p>
      <p>Seja em hooks, fun√ß√µes utilit√°rias ou dados externos, combinar desestrutura√ß√£o com tuplas tipadas √© uma forma
        de manter o c√≥digo claro, seguro e f√°cil de manter. ü§ì</p>
      <hr>
      <h2>1.5 Desestrutura√ß√£o de Objetos</h2>
      <p>A <strong>desestrutura√ß√£o de objetos</strong> √© um recurso introduzido no ES6 que permite extrair valores
        diretamente de propriedades de objetos em vari√°veis locais, com uma sintaxe declarativa e mais concisa.
        Diferentemente da desestrutura√ß√£o de arrays, que usa a <strong>posi√ß√£o</strong> dos elementos, a desestrutura√ß√£o
        de objetos se baseia em <strong>nomes de propriedades</strong>.</p>
      <p>Essa t√©cnica √© amplamente usada em c√≥digo moderno, especialmente em bibliotecas como React, onde props e
        objetos de estado s√£o frequentemente passados entre fun√ß√µes e componentes.</p>
      <h3>Extra√ß√£o direta de propriedades</h3>
      <p>Antes do ES6, acessar propriedades de um objeto exigia declara√ß√µes separadas:</p>
      <pre><code class="language-javascript">const usuario = { nome: &quot;Lucas&quot;, idade: 28 };
    
    const nome = usuario.nome;
    const idade = usuario.idade;
    </code></pre>
      <p>Com desestrutura√ß√£o, podemos escrever de forma mais enxuta:</p>
      <pre><code class="language-javascript">const usuario = { nome: &quot;Lucas&quot;, idade: 28 };
    const { nome, idade } = usuario;
    
    console.log(nome);  // &quot;Lucas&quot;
    console.log(idade); // 28
    </code></pre>
      <p>As vari√°veis <code>nome</code> e <code>idade</code> s√£o criadas automaticamente com os valores correspondentes
        do objeto. Essa forma √© especialmente √∫til quando se trabalha com objetos grandes, mas apenas algumas
        propriedades s√£o relevantes para um determinado trecho de c√≥digo.</p>
      <h3>Renomeando vari√°veis</h3>
      <p>√Äs vezes √© necess√°rio extrair uma propriedade, mas atribu√≠-la a uma vari√°vel com outro nome. Isso √© feito com a
        sintaxe <code>propriedade: novoNome</code>.</p>
      <pre><code class="language-javascript">const produto = { id: 42, preco: 99.9 };
    const { preco: valorUnitario } = produto;
    
    console.log(valorUnitario); // 99.9
    </code></pre>
      <p>Isso √© comum quando o nome da propriedade entra em conflito com outra vari√°vel local ou quando desejamos um
        nome mais expressivo.</p>
      <h3>Valores padr√£o</h3>
      <p>Tamb√©m √© poss√≠vel definir <strong>valores padr√£o</strong> na desestrutura√ß√£o, caso a propriedade n√£o exista no
        objeto ou esteja <code>undefined</code>.</p>
      <pre><code class="language-javascript">const config = { modo: &quot;escuro&quot; };
    const { modo, idioma = &quot;pt-BR&quot; } = config;
    
    console.log(modo);   // &quot;escuro&quot;
    console.log(idioma); // &quot;pt-BR&quot; (valor padr√£o)
    </code></pre>
      <p>Essa estrat√©gia √© muito √∫til para garantir valores seguros ao trabalhar com dados opcionais, como configura√ß√µes
        ou par√¢metros de fun√ß√µes.</p>
      <h3>Uso em par√¢metros de fun√ß√£o</h3>
      <p>Uma das aplica√ß√µes mais frequentes da desestrutura√ß√£o de objetos √© diretamente nos <strong>par√¢metros de
          fun√ß√µes</strong>. Isso permite acessar os dados de entrada j√° extra√≠dos, sem precisar declarar uma vari√°vel
        intermedi√°ria.</p>
      <pre><code class="language-javascript">function mostrarUsuario({ nome, idade }) {
      console.log(`${nome} tem ${idade} anos.`);
    }
    
    mostrarUsuario({ nome: &quot;Bruna&quot;, idade: 34 });
    // &quot;Bruna tem 34 anos.&quot;
    </code></pre>
      <p>Esse padr√£o √© bastante comum em callbacks, componentes React, hooks e manipuladores de eventos, pois torna o
        c√≥digo mais direto e limpo.</p>
      <h3>Aplica√ß√µes em React Native</h3>
      <p>No contexto do React Native, a desestrutura√ß√£o de objetos √© onipresente. Ela aparece, por exemplo:</p>
      <ul>
        <li>Ao extrair props de componentes:</li>
      </ul>
      <pre><code class="language-tsx">const Saudacao = ({ nome }: { nome: string }) =&gt; {
      return &lt;Text&gt;Ol√°, {nome}!&lt;/Text&gt;;
    };
    </code></pre>
      <ul>
        <li>Ao acessar dados de contextos ou hooks personalizados:</li>
      </ul>
      <pre><code class="language-tsx">const { usuario, sair } = useAuth();
    </code></pre>
      <ul>
        <li>Ou ao lidar com eventos:</li>
      </ul>
      <pre><code class="language-tsx">const handlePress = ({ nativeEvent }: GestureResponderEvent) =&gt; {
      console.log(nativeEvent);
    };
    </code></pre>
      <p>A clareza e concis√£o da desestrutura√ß√£o ajudam a reduzir c√≥digo repetitivo, aumentar a legibilidade e deixar
        expl√≠cito o que est√° sendo utilizado.</p>
      <h3>Considera√ß√µes sobre TypeScript</h3>
      <p>A desestrutura√ß√£o de objetos funciona exatamente da mesma forma em TypeScript, mas √© poss√≠vel (e recomendado)
        <strong>tipar os dados desestruturados</strong>, seja dentro da fun√ß√£o ou no momento da atribui√ß√£o. Vejamos
        abaixo.</p>
      <h4>1. Tipagem direta na fun√ß√£o</h4>
      <pre><code class="language-ts">type Usuario = {
      nome: string;
      idade: number;
    };
    
    function apresentar({ nome, idade }: Usuario): string {
      return `${nome} tem ${idade} anos.`;
    }
    </code></pre>
      <p>Aqui, o objeto passado como argumento √© desestruturado, e suas propriedades j√° s√£o validadas segundo o tipo
        <code>Usuario</code>.</p>
      <h4>2. Tipagem ao desestruturar</h4>
      <pre><code class="language-ts">const resposta: { ok: boolean; status: number } = { ok: true, status: 200 };
    const { ok, status }: { ok: boolean; status: number } = resposta;
    </code></pre>
      <p>Essa abordagem √© √∫til em casos pontuais ou quando se deseja tipar inline, mas em estruturas maiores, o ideal √©
        criar interfaces nomeadas.</p>
      <h3>Conclus√£o</h3>
      <p>A desestrutura√ß√£o de objetos melhora a legibilidade e reduz a verbosidade ao acessar propriedades espec√≠ficas.
        √â um recurso central no estilo moderno de escrita JavaScript e uma pr√°tica amplamente adotada em aplica√ß√µes
        React Native com TypeScript, tanto em componentes quanto em fun√ß√µes utilit√°rias. A capacidade de combinar
        desestrutura√ß√£o com tipagem expl√≠cita traz clareza, seguran√ßa e robustez ao desenvolvimento. üë©‚Äçüíª</p>
      <hr>
      <h2>1.6 Operador Spread e Rest (<code>...</code>)</h2>
      <p>O operador <code>...</code>, introduzido no ES6, serve para dois prop√≥sitos distintos, dependendo do contexto:
      </p>
      <ul>
        <li>Como <strong>spread</strong> (espalhamento), ele <strong>expande</strong> elementos de arrays ou
          propriedades de objetos.</li>
        <li>Como <strong>rest</strong> (resto), ele <strong>coleta</strong> m√∫ltiplos valores em uma √∫nica vari√°vel.
        </li>
      </ul>
      <p>Apesar de compartilharem a mesma sintaxe, esses dois usos t√™m comportamentos opostos, mas extremamente √∫teis ‚Äî
        especialmente em opera√ß√µes de composi√ß√£o, c√≥pia e passagem de par√¢metros. Seu uso √© cotidiano em projetos React
        Native, desde a manipula√ß√£o de arrays at√© a composi√ß√£o de props em componentes.</p>
      <h3>Spread: expandindo arrays ou objetos</h3>
      <p>O uso como <strong>spread</strong> permite <strong>copiar ou combinar estruturas</strong> (arrays ou objetos),
        espalhando seus elementos onde m√∫ltiplos valores s√£o esperados.</p>
      <h4>Arrays</h4>
      <pre><code class="language-javascript">const numeros = [1, 2, 3];
    const maisNumeros = [...numeros, 4, 5];
    
    console.log(maisNumeros); // [1, 2, 3, 4, 5]
    </code></pre>
      <p>Nesse exemplo, <code>...numeros</code> insere os elementos do array original dentro de um novo array. Isso √©
        √∫til para <strong>copiar</strong> arrays (sem refer√™ncia) ou para <strong>adicionar elementos</strong> em novas
        estruturas sem mutar o original.</p>
      <h4>Objetos</h4>
      <pre><code class="language-javascript">const usuario = { nome: &quot;Ana&quot;, idade: 25 };
    const usuarioAtualizado = { ...usuario, idade: 26 };
    
    console.log(usuarioAtualizado); // { nome: &quot;Ana&quot;, idade: 26 }
    </code></pre>
      <p>No caso de objetos, o spread copia todas as propriedades existentes. Se alguma chave for repetida, a nova
        sobrescreve a anterior ‚Äî √∫til para atualiza√ß√µes parciais em estruturas imut√°veis, como em <code>useState</code>.
      </p>
      <h3>Capturando o restante com o operador <code>...</code> (rest syntax)</h3>
      <p>Al√©m de ser usado para <strong>espalhar elementos</strong> em arrays ou objetos (spread), o operador
        <code>...</code> tamb√©m pode ser utilizado para <strong>capturar o restante dos elementos</strong> durante uma
        desestrutura√ß√£o. Esse uso √© conhecido como <strong>rest syntax</strong>, ou ‚Äúsintaxe de captura do restante‚Äù.
      </p>
      <blockquote>
        <p>‚ö†Ô∏è <strong>Aten√ß√£o:</strong> aqui, o termo ‚Äúrest‚Äù n√£o tem nenhuma rela√ß√£o com o padr√£o arquitetural REST
          usado em APIs. Trata-se apenas de uma forma abreviada para ‚Äúrestante‚Äù ‚Äî ou seja, os valores que
          <strong>sobram</strong> ap√≥s uma desestrutura√ß√£o.</p>
      </blockquote>
      <p>Esse recurso √© bastante √∫til quando queremos extrair apenas uma parte dos dados e armazenar o restante em uma
        nova vari√°vel, tanto em arrays quanto em objetos.</p>
      <h4>Rest em Arrays</h4>
      <p>No exemplo abaixo, estamos desestruturando o primeiro valor do array e armazenando os demais em uma nova
        vari√°vel chamada <code>restantes</code>.</p>
      <pre><code class="language-javascript">const [primeiro, ...restantes] = [10, 20, 30, 40];
    
    console.log(primeiro);   // 10
    console.log(restantes);  // [20, 30, 40]
    </code></pre>
      <p>Esse padr√£o √© √∫til em fun√ß√µes que operam sobre listas vari√°veis ou que desejam processar o primeiro item
        separadamente dos demais.</p>
      <h4>Rest em Objetos</h4>
      <p>A mesma ideia vale para objetos. Podemos extrair uma ou mais propriedades espec√≠ficas e capturar o restante em
        uma nova vari√°vel:</p>
      <pre><code class="language-javascript">const { nome, ...outrosDados } = { nome: &quot;Carlos&quot;, idade: 33, ativo: true };
    
    console.log(nome);        // &quot;Carlos&quot;
    console.log(outrosDados); // { idade: 33, ativo: true }
    </code></pre>
      <p>Esse padr√£o √© comum em manipula√ß√£o de dados din√¢micos, onde queremos manter algumas informa√ß√µes intactas e
        trabalhar apenas com o restante.</p>
      <h4>Exemplo em Componentes React Native</h4>
      <p>No desenvolvimento com React Native, o uso da sintaxe rest √© frequente em componentes que recebem m√∫ltiplas
        props:</p>
      <pre><code class="language-tsx">const MeuBotao = ({ titulo, ...props }) =&gt; {
      return &lt;Button title={titulo} {...props} /&gt;;
    };
    </code></pre>
      <p>Nesse caso, extra√≠mos apenas a prop <code>titulo</code> e repassamos todas as demais para o componente
        <code>&lt;Button /&gt;</code>. Isso torna o componente mais flex√≠vel e reutiliz√°vel, especialmente quando n√£o
        sabemos todas as props que podem ser recebidas.</p>
      <h3>Fun√ß√µes com argumentos vari√°veis</h3>
      <p>O operador <code>...</code> tamb√©m √© utilizado para declarar fun√ß√µes que aceitam <strong>um n√∫mero vari√°vel de
          argumentos</strong>. Esse uso √© especialmente comum em utilit√°rios matem√°ticos, constru√ß√£o de logs ou fun√ß√µes
        que recebem m√∫ltiplos par√¢metros sem nome fixo.</p>
      <pre><code class="language-javascript">function somar(...numeros) {
      return numeros.reduce((total, n) =&gt; total + n, 0);
    }
    
    console.log(somar(1, 2, 3, 4)); // 10
    </code></pre>
      <p>Nesse caso, <code>numeros</code> √© um array com todos os argumentos passados. Essa abordagem substitui o uso do
        objeto <code>arguments</code>, oferecendo maior clareza e seguran√ßa.</p>
      <hr>
      <h3>Considera√ß√µes sobre TypeScript</h3>
      <p>No TypeScript, a sintaxe rest continua funcionando da mesma forma, mas requer aten√ß√£o √† <strong>tipagem
          expl√≠cita</strong>, principalmente quando h√° m√∫ltiplos tipos envolvidos.</p>
      <h4>Tipagem de arrays com rest</h4>
      <p>Ao utilizar par√¢metros vari√°veis em fun√ß√µes, podemos indicar o tipo dos elementos com a nota√ß√£o
        <code>: tipo[]</code>:</p>
      <pre><code class="language-ts">function somar(...numeros: number[]): number {
      return numeros.reduce((total, n) =&gt; total + n, 0);
    }
    </code></pre>
      <h4>Tipagem em objetos com rest</h4>
      <p>Ao desestruturar objetos, o TypeScript consegue inferir o tipo do restante. Mesmo assim, podemos indicar
        explicitamente:</p>
      <pre><code class="language-ts">type Usuario = {
      nome: string;
      idade: number;
      ativo: boolean;
    };
    
    const { nome, ...resto }: Usuario = {
      nome: &quot;Jo√£o&quot;,
      idade: 30,
      ativo: true,
    };
    </code></pre>
      <p>Nesse caso, o TypeScript reconhece que <code>resto</code> tem tipo
        <code>{ idade: number; ativo: boolean }</code>.</p>
      <h4>Tipos gen√©ricos com rest</h4>
      <p>√â poss√≠vel usar rest parameters com tipos gen√©ricos para fun√ß√µes reutiliz√°veis:</p>
      <pre><code class="language-ts">function logarTudo&lt;T extends any[]&gt;(...args: T): void {
      console.log(...args);
    }
    
    logarTudo(&quot;texto&quot;, 42, true); // OK
    </code></pre>
      <p>Essa abordagem √© √∫til em fun√ß√µes auxiliares que recebem argumentos variados, mantendo a tipagem precisa e
        reutiliz√°vel.</p>
      <h3>Resumindo...</h3>
      <p>O operador <code>...</code> √© uma das ferramentas mais vers√°teis do JavaScript moderno. Seja expandindo
        estruturas com <strong>spread</strong> ou coletando m√∫ltiplos valores quando usado como <strong>rest
          syntax</strong>, seu uso reduz boilerplate, melhora a legibilidade e permite compor objetos e arrays de forma
        declarativa. Em aplica√ß√µes com React Native e TypeScript, seu dom√≠nio √© importante para manipular props,
        estados, listas e dados din√¢micos.</p>
      <hr>
      <h2>1.7 M√©todos de Array: <code>map</code>, <code>filter</code>, <code>reduce</code>, <code>find</code></h2>
      <p>No desenvolvimento moderno com JavaScript ‚Äî especialmente em frameworks como React e React Native ‚Äî h√° uma
        forte valoriza√ß√£o de princ√≠pios da <strong>programa√ß√£o funcional</strong>. Esse paradigma promove o uso de
        <strong>fun√ß√µes puras</strong>, <strong>imutabilidade</strong>, <strong>composi√ß√£o</strong> e <strong>aus√™ncia
          de efeitos colaterais</strong>, resultando em c√≥digo mais previs√≠vel, leg√≠vel e f√°cil de testar.</p>
      <p>Os arrays em JavaScript oferecem suporte direto a esse estilo por meio de m√©todos nativos como
        <code>map</code>, <code>filter</code>, <code>find</code> e <code>reduce</code>. Essas fun√ß√µes de ordem superior
        permitem transformar, filtrar, localizar ou acumular dados de forma <strong>declarativa</strong>, sem alterar o
        array original.</p>
      <p>Esses m√©todos s√£o amplamente utilizados em aplica√ß√µes React Native para:</p>
      <ul>
        <li>Renderizar listas de forma din√¢mica;</li>
        <li>Processar dados recebidos de APIs;</li>
        <li>Construir estados derivados com l√≥gica pura;</li>
        <li>Realizar opera√ß√µes como buscas, filtragens e somat√≥rios com clareza e seguran√ßa.</li>
      </ul>
      <p>Vamos explorar cada um desses m√©todos, mostrando tanto seu funcionamento quanto sua aplica√ß√£o pr√°tica ‚Äî sempre
        com foco no estilo funcional de codifica√ß√£o e nos benef√≠cios que ele traz ao dia a dia do desenvolvimento
        mobile. ü§†</p>
      <h3><code>map()</code> ‚Äì Transforma√ß√£o de elementos</h3>
      <p>O m√©todo <code>map()</code> percorre todos os elementos do array e <strong>retorna um novo array</strong>, onde
        cada item √© o resultado da aplica√ß√£o de uma fun√ß√£o sobre o item original. O tamanho do array resultante √© sempre
        o mesmo que o original.</p>
      <pre><code class="language-javascript">const numeros = [1, 2, 3];
    const dobrados = numeros.map(n =&gt; n * 2);
    
    console.log(dobrados); // [2, 4, 6]
    </code></pre>
      <p>Aqui, cada n√∫mero foi multiplicado por 2. O array original (<code>numeros</code>) permanece inalterado.</p>
      <h4>Exemplo pr√°tico: exibindo nomes</h4>
      <pre><code class="language-javascript">const usuarios = [
      { nome: &quot;Ana&quot;, idade: 25 },
      { nome: &quot;Carlos&quot;, idade: 30 }
    ];
    
    const nomes = usuarios.map(usuario =&gt; usuario.nome);
    console.log(nomes); // [&quot;Ana&quot;, &quot;Carlos&quot;]
    </code></pre>
      <p>Essa t√©cnica √© comum ao renderizar listas no React:</p>
      <pre><code class="language-tsx">{usuarios.map(usuario =&gt; (
      &lt;Text key={usuario.nome}&gt;{usuario.nome}&lt;/Text&gt;
    ))}
    </code></pre>
      <h3><code>filter()</code> ‚Äì Filtragem de elementos</h3>
      <p>O m√©todo <code>filter()</code> retorna um novo array com os elementos que <strong>passam em um teste
          l√≥gico</strong> (retornam <code>true</code>). Os elementos que n√£o satisfazem a condi√ß√£o s√£o ignorados.</p>
      <pre><code class="language-javascript">const numeros = [1, 2, 3, 4, 5];
    const pares = numeros.filter(n =&gt; n % 2 === 0);
    
    console.log(pares); // [2, 4]
    </code></pre>
      <h4>Exemplo pr√°tico: usu√°rios ativos</h4>
      <pre><code class="language-javascript">const usuarios = [
      { nome: &quot;Ana&quot;, ativo: true },
      { nome: &quot;Carlos&quot;, ativo: false },
      { nome: &quot;Jo√£o&quot;, ativo: true }
    ];
    
    const ativos = usuarios.filter(u =&gt; u.ativo);
    console.log(ativos);
    // [
    //   { nome: &quot;Ana&quot;, ativo: true },
    //   { nome: &quot;Jo√£o&quot;, ativo: true }
    // ]
    </code></pre>
      <p>Essa abordagem √© √∫til, por exemplo, para exibir apenas tarefas incompletas, produtos dispon√≠veis ou itens
        favoritos.</p>
      <h3><code>reduce()</code> ‚Äì Acumula√ß√£o de valores</h3>
      <p>O m√©todo <code>reduce()</code> executa uma fun√ß√£o redutora sobre todos os elementos do array,
        <strong>acumulando um √∫nico valor final</strong>. Ele pode ser usado para somar n√∫meros, combinar objetos ou
        compor strings.</p>
      <pre><code class="language-javascript">const numeros = [1, 2, 3, 4];
    const soma = numeros.reduce((acumulador, atual) =&gt; acumulador + atual, 0);
    
    console.log(soma); // 10
    </code></pre>
      <p>A fun√ß√£o recebe dois argumentos principais:</p>
      <ul>
        <li><code>acumulador</code>: valor que vai sendo carregado entre itera√ß√µes</li>
        <li><code>atual</code>: o elemento atual do array</li>
      </ul>
      <p>O segundo argumento (<code>0</code>) √© o valor inicial do acumulador.</p>
      <h4>Exemplo pr√°tico: somando totais</h4>
      <pre><code class="language-javascript">const compras = [
      { item: &quot;Livro&quot;, preco: 30 },
      { item: &quot;Caneta&quot;, preco: 5 },
      { item: &quot;Caderno&quot;, preco: 15 }
    ];
    
    const total = compras.reduce((soma, compra) =&gt; soma + compra.preco, 0);
    console.log(total); // 50
    </code></pre>
      <p>Esse padr√£o √© muito usado para <strong>calcular totais</strong> em carrinhos de compras, pontua√ß√£o de usu√°rios
        ou estat√≠sticas acumuladas.</p>
      <h3><code>find()</code> ‚Äì Encontrando o primeiro que satisfaz a condi√ß√£o</h3>
      <p>O m√©todo <code>find()</code> retorna o <strong>primeiro elemento</strong> do array que satisfaz uma condi√ß√£o.
        Se nenhum for encontrado, retorna <code>undefined</code>. Diferente de <code>filter()</code>, que retorna
        v√°rios, <code>find()</code> retorna apenas um item ‚Äî o primeiro que bater com a l√≥gica.</p>
      <pre><code class="language-javascript">const numeros = [1, 2, 3, 4];
    const encontrado = numeros.find(n =&gt; n &gt; 2);
    
    console.log(encontrado); // 3
    </code></pre>
      <h4>Exemplo pr√°tico: buscar usu√°rio pelo nome</h4>
      <pre><code class="language-javascript">const usuarios = [
      { nome: &quot;Ana&quot;, id: 1 },
      { nome: &quot;Carlos&quot;, id: 2 }
    ];
    
    const resultado = usuarios.find(u =&gt; u.nome === &quot;Carlos&quot;);
    console.log(resultado); // { nome: &quot;Carlos&quot;, id: 2 }
    </code></pre>
      <p>Essa t√©cnica √© √∫til para buscar rapidamente um item espec√≠fico de uma lista ‚Äî por exemplo, o usu√°rio logado, o
        produto clicado, ou um item marcado como favorito.</p>
      <h3>Rela√ß√£o com Programa√ß√£o Funcional</h3>
      <p>Como j√° mencionamos na introdu√ß√£o dessa se√ß√£o, √© importante destacar que os m√©todos <code>map</code>,
        <code>filter</code>, <code>reduce</code> e <code>find</code> s√£o pilares da <strong>programa√ß√£o
          funcional</strong> aplicada ao JavaScript. Esse paradigma se baseia em <strong>fun√ß√µes puras, imutabilidade,
          composi√ß√£o e aus√™ncia de efeitos colaterais</strong>. A ideia central √© transformar dados por meio de fun√ß√µes,
        ao inv√©s de modificar estruturas diretamente.</p>
      <p>Vimos os exemplos dos m√©todos acima, mas de qualquer forma vamos aproveitar para entender como eles se
        relacionam com esses pilares.</p>
      <h4><strong>Fun√ß√µes puras</strong></h4>
      <p>Cada m√©todo recebe uma <strong>fun√ß√£o de callback</strong> que n√£o deve alterar o estado externo. Em vez disso,
        ela transforma ou extrai dados com base apenas em seus par√¢metros de entrada.</p>
      <pre><code class="language-javascript">const dobrar = n =&gt; n * 2;
    const resultado = [1, 2, 3].map(dobrar); // [2, 4, 6]
    </code></pre>
      <p>A fun√ß√£o <code>dobrar</code> √© pura: dado o mesmo <code>n</code>, sempre retorna o mesmo resultado, sem acessar
        ou modificar nada al√©m de seus argumentos.</p>
      <h4><strong>Imutabilidade</strong></h4>
      <p>Todos esses m√©todos <strong>n√£o alteram o array original</strong>. Em vez disso, eles produzem <strong>novas
          estruturas</strong> com base na l√≥gica definida:</p>
      <pre><code class="language-javascript">const numeros = [1, 2, 3];
    const pares = numeros.filter(n =&gt; n % 2 === 0);
    
    console.log(numeros); // [1, 2, 3] ‚Äî permanece intacto
    console.log(pares);   // [2]
    </code></pre>
      <p>Essa caracter√≠stica √© essencial em aplica√ß√µes React e React Native, onde trabalhar com dados imut√°veis evita
        comportamentos inesperados e melhora a previsibilidade da interface.</p>
      <h4><strong>Composi√ß√£o de fun√ß√µes</strong></h4>
      <p>A programa√ß√£o funcional valoriza a <strong>composi√ß√£o</strong> ‚Äî isto √©, o encadeamento de pequenas fun√ß√µes que
        fazem transforma√ß√µes simples e leg√≠veis:</p>
      <pre><code class="language-javascript">const dados = [1, 2, 3, 4, 5];
    
    const resultado = dados
      .filter(n =&gt; n % 2 === 0)      // mant√©m apenas pares
      .map(n =&gt; n * 10)              // multiplica por 10
      .reduce((soma, n) =&gt; soma + n, 0); // soma os resultados
    
    console.log(resultado); // 60
    </code></pre>
      <p>Esse padr√£o torna o c√≥digo mais declarativo e f√°cil de testar, j√° que cada etapa √© isolada e previs√≠vel.</p>
      <h4><strong>Abstra√ß√£o e reutiliza√ß√£o</strong></h4>
      <p>As fun√ß√µes passadas a esses m√©todos s√£o <strong>valores de primeira classe</strong> ‚Äî ou seja, podem ser
        armazenadas em vari√°veis, passadas como par√¢metros ou retornadas de outras fun√ß√µes. Isso facilita a
        reutiliza√ß√£o:</p>
      <pre><code class="language-javascript">const isPar = (n: number) =&gt; n % 2 === 0;
    const emReais = (valor: number) =&gt; `R$ ${valor.toFixed(2)}`;
    
    const valores = [10, 15, 22, 7];
    
    const resultado = valores
      .filter(isPar)
      .map(emReais);
    
    console.log(resultado); // [&quot;R$ 10.00&quot;, &quot;R$ 22.00&quot;]
    </code></pre>
      <p>Essa abordagem segue o princ√≠pio da <strong>separa√ß√£o de preocupa√ß√µes</strong>: cada fun√ß√£o faz uma coisa
        apenas, e o sistema final emerge da combina√ß√£o delas.</p>
      <h3>Programa√ß√£o funcional em React Native</h3>
      <p>Esses princ√≠pios s√£o especialmente √∫teis no desenvolvimento com React Native, por diversos motivos:</p>
      <ul>
        <li><strong>Componentes funcionais</strong> s√£o o padr√£o atual ‚Äî e foram projetados com a ideia de pureza e
          imutabilidade.</li>
        <li><strong>Hooks como <code>useState</code> e <code>useReducer</code></strong> exigem que os dados sejam
          transformados sem muta√ß√µes diretas.</li>
        <li>A <strong>renderiza√ß√£o declarativa</strong> do React favorece opera√ß√µes como <code>.map()</code> para
          listas, evitando la√ßos imperativos e muta√ß√µes.</li>
      </ul>
      <p>Exemplo t√≠pico:</p>
      <pre><code class="language-tsx">const ListaProdutos = ({ produtos }) =&gt; {
      return (
        &lt;FlatList
          data={produtos.filter(p =&gt; p.ativo)}
          renderItem={({ item }) =&gt; &lt;Text&gt;{item.nome}&lt;/Text&gt;}
          keyExtractor={item =&gt; item.id.toString()}
        /&gt;
      );
    };
    </code></pre>
      <p>A fun√ß√£o <code>filter</code> evita l√≥gica de controle manual com <code>for</code>, e o c√≥digo se mant√©m claro,
        reutiliz√°vel e de f√°cil manuten√ß√£o.</p>
      <h3>Considera√ß√µes sobre TypeScript</h3>
      <p>Al√©m de tudo que mencionamos acima, todos esses m√©todos funcionam normalmente em TypeScript, mas voc√™ pode
        <strong>aproveitar os tipos gen√©ricos</strong> para obter ainda mais seguran√ßa:</p>
      <h4>Infer√™ncia autom√°tica</h4>
      <pre><code class="language-ts">const nomes = [&quot;Ana&quot;, &quot;Carlos&quot;];
    const maiusculos = nomes.map(n =&gt; n.toUpperCase()); // string[]
    </code></pre>
      <h4>Tipagem expl√≠cita em callbacks</h4>
      <pre><code class="language-ts">type Usuario = { nome: string; idade: number };
    
    const usuarios: Usuario[] = [...];
    
    const maiores = usuarios.filter((u: Usuario) =&gt; u.idade &gt;= 18);
    </code></pre>
      <h4>Tipagem no <code>reduce</code></h4>
      <pre><code class="language-ts">type Item = { valor: number };
    
    const itens: Item[] = [{ valor: 10 }, { valor: 20 }];
    
    const total = itens.reduce((soma: number, item) =&gt; soma + item.valor, 0);
    </code></pre>
      <p>Se voc√™ n√£o tipar o acumulador, o TypeScript pode inferir incorretamente o tipo, especialmente se o valor
        inicial for omitido.</p>
      <h3><em>Costurando</em> tudo ü™¢</h3>
      <p>Os m√©todos <code>map</code>, <code>filter</code>, <code>reduce</code> e <code>find</code> s√£o ferramentas
        poderosas e expressivas para transformar e manipular arrays de forma funcional, declarativa e segura. Dominar
        essas fun√ß√µes permite escrever c√≥digo mais conciso, evitar la√ßos imperativos (<code>for</code>,
        <code>while</code>) e se alinhar ao estilo moderno de desenvolvimento JavaScript ‚Äî algo especialmente √∫til no
        React Native, onde a manipula√ß√£o de listas e estados derivados √© rotina.</p>
      <p>A utiliza√ß√£o de m√©todos como <code>map</code>, <code>filter</code>, <code>reduce</code> e <code>find</code> n√£o
        √© apenas uma conveni√™ncia sint√°tica ‚Äî ela representa uma <strong>mudan√ßa de estilo</strong>: do imperativo para
        o funcional. Essa mudan√ßa torna o c√≥digo mais leg√≠vel, modular e confi√°vel, al√©m de estar perfeitamente alinhada
        aos princ√≠pios do React e do TypeScript moderno. Compreender e adotar essas pr√°ticas √© um passo essencial para
        escrever software mais limpo, previs√≠vel e escal√°vel.</p>
      <hr>
      <h2>1.8 Resum√£o sobre os Fundamentos Modernos de JavaScript</h2>
      <p>Nesta primeira parte da aula, revisamos os principais recursos do JavaScript moderno que moldam a forma como
        escrevemos c√≥digo atualmente ‚Äî especialmente no contexto do desenvolvimento com React e React Native.</p>
      <p>Recursos como <code>let</code> e <code>const</code>, desestrutura√ß√£o, template literals e arrow functions nos
        permitem <strong>expressar inten√ß√µes de forma mais clara e segura</strong>, enquanto operadores como spread/rest
        e m√©todos como <code>map</code>, <code>filter</code> e <code>reduce</code> nos colocam em sintonia com os
        princ√≠pios da <strong>programa√ß√£o funcional</strong>, favorecendo <strong>imutabilidade, composi√ß√£o e
          previsibilidade</strong>.</p>
      <p>Al√©m disso, vimos como essas constru√ß√µes est√£o presentes o tempo todo na pr√°tica cotidiana: em fun√ß√µes de
        manipula√ß√£o de estado, passagem de props, renderiza√ß√£o de listas, configura√ß√£o de objetos, e at√© na maneira como
        modelamos dados vindos de APIs ou transformamos entradas do usu√°rio.</p>
      <p>A familiaridade com essas ferramentas √© fundamental ‚Äî elas formam o vocabul√°rio b√°sico da programa√ß√£o
        JavaScript moderna e, consequentemente, da base sobre a qual construiremos nossas aplica√ß√µes m√≥veis com React
        Native.</p>
      <p>Agora que revisitamos os fundamentos modernos do JavaScript, √© hora de dar um passo adiante e conhecer o que o
        <strong>TypeScript</strong> adiciona a essa base. Como dissemos inicialmente, TypeScript n√£o substitui
        JavaScript ‚Äî ele <strong>estende</strong> sua sintaxe e funcionalidades, permitindo que possamos <strong>tipar
          dados, fun√ß√µes e objetos de forma expl√≠cita</strong>. Isso nos ajuda a detectar erros antes da execu√ß√£o,
        documentar melhor nossas inten√ß√µes e tornar o c√≥digo mais previs√≠vel e confi√°vel.</p>
      <p>Na pr√≥xima se√ß√£o, vamos explorar de forma pr√°tica os principais recursos da linguagem, como tipos primitivos,
        interfaces, generics e infer√™ncia, sempre com foco em como isso melhora a qualidade do c√≥digo no desenvolvimento
        mobile. üöÄ</p>
      <hr>
      <h2>2. TypeScript</h2>
      <h2>2.1 Tipos Primitivos e Anota√ß√£o de Tipos</h2>
      <p>O TypeScript √© um superconjunto do JavaScript que adiciona <strong>tipagem est√°tica opcional</strong> √†
        linguagem. Isso significa que podemos <strong>declarar explicitamente o tipo de cada vari√°vel, par√¢metro de
          fun√ß√£o, retorno e estrutura de dados</strong> ‚Äî e o compilador verifica se os usos est√£o coerentes com os
        tipos declarados.</p>
      <p>Essa valida√ß√£o ocorre <strong>em tempo de desenvolvimento</strong>, ajudando a capturar erros antes mesmo de
        executar o c√≥digo.</p>
      <h3>Tipos primitivos em TypeScript</h3>
      <p>Os <strong>tipos primitivos</strong> dispon√≠veis em TypeScript s√£o os mesmos do JavaScript, mas com a vantagem
        de que agora podemos express√°-los de forma clara e expl√≠cita:</p>
      <ul>
        <li><code>string</code> ‚Äî sequ√™ncia de caracteres</li>
        <li><code>number</code> ‚Äî n√∫meros inteiros e decimais (n√£o h√° distin√ß√£o entre int e float)</li>
        <li><code>boolean</code> ‚Äî verdadeiro ou falso</li>
        <li><code>null</code> e <code>undefined</code> ‚Äî valores especiais para aus√™ncia</li>
        <li><code>bigint</code> ‚Äî n√∫meros inteiros muito grandes (pouco usado em aplica√ß√µes mobile)</li>
        <li><code>symbol</code> ‚Äî usado para identificadores √∫nicos (mais avan√ßado)</li>
      </ul>
      <h4>Exemplo b√°sico:</h4>
      <pre><code class="language-ts">let nome: string = &quot;Camila&quot;;
    let idade: number = 28;
    let ativo: boolean = true;
    </code></pre>
      <p>A sintaxe <code>nome: string</code> indica ao TypeScript que a vari√°vel <code>nome</code> deve conter apenas
        valores do tipo string. Se tentarmos atribuir outro tipo, o compilador acusar√° erro:</p>
      <pre><code class="language-ts">nome = 42; // ‚ùå Erro: number n√£o √© atribu√≠vel a string
    </code></pre>
      <h3>Infer√™ncia de tipos</h3>
      <p>Voc√™ <strong>n√£o √© obrigado a declarar tipos o tempo todo</strong>. O TypeScript √© inteligente o suficiente
        para <strong>inferir o tipo com base no valor inicial</strong>, e s√≥ exige declara√ß√£o expl√≠cita quando n√£o
        consegue determinar o tipo com seguran√ßa.</p>
      <pre><code class="language-ts">let cidade = &quot;S√£o Paulo&quot;; // inferido como string
    let pontos = 100;         // inferido como number
    </code></pre>
      <p>No entanto, sempre que quiser <strong>documentar a inten√ß√£o</strong> ou <strong>evitar ambiguidade</strong>, √©
        recomend√°vel declarar os tipos explicitamente ‚Äî especialmente em vari√°veis exportadas, par√¢metros de fun√ß√£o e
        dados de entrada externos.</p>
      <h3>Fun√ß√µes com tipos</h3>
      <p>Tamb√©m √© poss√≠vel (e altamente recomend√°vel) <strong>tipar os par√¢metros e o valor de retorno das
          fun√ß√µes</strong>. Isso ajuda o TypeScript a garantir que a fun√ß√£o seja usada corretamente em qualquer lugar.
      </p>
      <pre><code class="language-ts">function saudar(nome: string): string {
      return `Ol√°, ${nome}`;
    }
    </code></pre>
      <p>Neste caso:</p>
      <ul>
        <li><code>nome: string</code> define o tipo do par√¢metro.</li>
        <li><code>: string</code> ap√≥s os par√™nteses indica que a fun√ß√£o <strong>retorna uma string</strong>.</li>
      </ul>
      <p>Se algu√©m tentar chamar <code>saudar(123)</code>, o TypeScript apontar√° um erro imediato.</p>
      <h3>Tipos <code>undefined</code> e <code>null</code></h3>
      <p>Por padr√£o, o TypeScript considera que uma vari√°vel tipada como <code>string</code> ou <code>number</code>
        <strong>n√£o pode receber <code>undefined</code> ou <code>null</code></strong>, a menos que seja explicitamente
        permitido.</p>
      <pre><code class="language-ts">let email: string = &quot;a@b.com&quot;;
    email = undefined; // ‚ùå Erro
    
    let telefone: string | undefined;
    telefone = undefined; // ‚úÖ permitido por causa da uni√£o de tipos
    </code></pre>
      <p>Essa distin√ß√£o √© importante para evitar acessos indevidos a vari√°veis n√£o inicializadas ou ausentes ‚Äî um
        problema comum em JavaScript puro.</p>
      <h3>Observa√ß√£o sobre <code>any</code></h3>
      <p>O tipo especial <code>any</code> representa <strong>qualquer tipo de dado</strong>, desativando temporariamente
        a verifica√ß√£o de tipo do TypeScript. Ele deve ser usado com cautela, apenas quando o tipo do dado √© realmente
        desconhecido (ex: dados vindos de APIs sem contrato definido).</p>
      <pre><code class="language-ts">let dado: any = &quot;texto&quot;;
    dado = 42; // permitido
    </code></pre>
      <p>Embora <code>any</code> possa parecer pr√°tico, seu uso em excesso <strong>anula os benef√≠cios do
          TypeScript</strong>, e deve ser evitado em c√≥digo bem estruturado. üëÜüèªü§ì</p>
      <h3>Aplica√ß√µes pr√°ticas em React Native</h3>
      <p>A tipagem de vari√°veis √© extremamente √∫til ao desenvolver componentes ou usar hooks:</p>
      <pre><code class="language-tsx">const [contador, setContador] = useState&lt;number&gt;(0);
    
    function incrementar(valor: number): void {
      setContador(prev =&gt; prev + valor);
    }
    </code></pre>
      <p>Ao declarar <code>useState&lt;number&gt;</code>, garantimos que o contador ser√° sempre um n√∫mero, e evitamos
        erros como:</p>
      <pre><code class="language-ts">setContador(&quot;um&quot;); // ‚ùå Erro: string n√£o √© atribu√≠vel a number
    </code></pre>
      <p>Esse tipo de seguran√ßa √© particularmente importante quando trabalhamos com <strong>eventos, dados externos e
          intera√ß√µes com o usu√°rio</strong>.</p>
      <h3>Conclus√µes</h3>
      <p>Com a tipagem b√°sica do TypeScript, ganhamos <strong>clareza, seguran√ßa e confiabilidade</strong>. Ao
        explicitar os tipos de vari√°veis e fun√ß√µes, conseguimos capturar erros logo na escrita do c√≥digo, al√©m de
        melhorar o autocompletar das IDEs, facilitar refatora√ß√µes e documentar de forma impl√≠cita as regras de neg√≥cio.
      </p>
      <p>Essa base √© necess√°ria para explorarmos, nas pr√≥ximas se√ß√µes, tipos compostos, interfaces, enums, generics e
        valida√ß√£o estrutural.</p>
      <hr>
      <h2>2.2 Tipos Compostos: Arrays, Tuplas e Uni√£o de Tipos</h2>
      <p>Ap√≥s dominar os <strong>tipos primitivos</strong>, √© natural expandirmos para <strong>estruturas
          compostas</strong>, que representam <strong>cole√ß√µes de dados</strong> ou <strong>valores alternativos
          poss√≠veis</strong>. No TypeScript, isso √© feito com os tipos de <strong>arrays</strong>,
        <strong>tuplas</strong> e <strong>uni√µes</strong>.</p>
      <p>Esses recursos s√£o essenciais em qualquer aplica√ß√£o real ‚Äî inclusive no desenvolvimento mobile com React Native
        ‚Äî pois nos permitem modelar listas de dados, respostas de APIs, props opcionais e muito mais.</p>
      <h3>Arrays</h3>
      <p>Arrays em TypeScript podem ser tipados de duas formas equivalentes:</p>
      <ol>
        <li>
          <p><strong>Nota√ß√£o com colchetes</strong>:</p>
          <pre><code class="language-ts">let numeros: number[] = [1, 2, 3];
    </code></pre>
        </li>
        <li>
          <p><strong>Nota√ß√£o gen√©rica</strong>:</p>
          <pre><code class="language-ts">let nomes: Array&lt;string&gt; = [&quot;Ana&quot;, &quot;Carlos&quot;];
    </code></pre>
        </li>
      </ol>
      <p>Ambas s√£o aceitas, e a escolha entre elas √© uma quest√£o de prefer√™ncia. A nota√ß√£o com colchetes √© mais comum e
        mais leg√≠vel no contexto do React Native.</p>
      <h4>Acessos e valida√ß√µes</h4>
      <p>O TypeScript garante que apenas elementos do tipo especificado podem ser inseridos:</p>
      <pre><code class="language-ts">numeros.push(4);      // OK
    numeros.push(&quot;cinco&quot;); // ‚ùå Erro: string n√£o √© atribu√≠vel a number
    </code></pre>
      <p>Ao acessar um √≠ndice, o TypeScript sabe o tipo esperado:</p>
      <pre><code class="language-ts">const primeiro = nomes[0]; // string
    </code></pre>
      <h3>Arrays de objetos</h3>
      <p>Ao tipar arrays de objetos, usamos o mesmo racioc√≠nio, definindo o tipo dos itens:</p>
      <pre><code class="language-ts">type Produto = { nome: string; preco: number };
    
    const lista: Produto[] = [
      { nome: &quot;Caderno&quot;, preco: 10 },
      { nome: &quot;Caneta&quot;, preco: 2 }
    ];
    </code></pre>
      <p>Isso permite acessar e manipular dados com autocompletar, valida√ß√£o e seguran√ßa ‚Äî muito √∫til em listas
        renderizadas com <code>FlatList</code>, por exemplo:</p>
      <pre><code class="language-tsx">&lt;FlatList
      data={lista}
      renderItem={({ item }) =&gt; &lt;Text&gt;{item.nome} - R$ {item.preco}&lt;/Text&gt;}
    /&gt;
    </code></pre>
      <h3>Tuplas</h3>
      <p>Uma <strong>tupla</strong> √© um array de tamanho fixo e com tipos diferentes em posi√ß√µes espec√≠ficas. Ela √©
        √∫til quando a <strong>ordem e o tipo de cada elemento importam</strong> ‚Äî por exemplo, quando uma fun√ß√£o retorna
        m√∫ltiplos valores com significados distintos.</p>
      <pre><code class="language-ts">const coordenadas: [number, number] = [10.5, 20.3];
    </code></pre>
      <p>A vari√°vel <code>coordenadas</code> s√≥ aceita dois n√∫meros, nessa ordem. Qualquer valor a mais ou tipos errados
        geram erro:</p>
      <pre><code class="language-ts">coordenadas[0] = 99;       // OK
    coordenadas[1] = &quot;alto&quot;;   // ‚ùå Erro
    coordenadas[2] = 42;       // ‚ùå Erro: √≠ndice fora do comprimento
    </code></pre>
      <p>Tuplas s√£o muito utilizadas em <strong>hooks do React</strong>, como <code>useState</code>:</p>
      <pre><code class="language-ts">const [contador, setContador]: [number, (valor: number) =&gt; void] = useState(0);
    </code></pre>
      <h3>Uni√£o de Tipos (<code>|</code>)</h3>
      <p>A <strong>uni√£o de tipos</strong> permite que uma vari√°vel aceite <strong>dois ou mais tipos
          diferentes</strong>. Esse recurso √© especialmente √∫til para representar situa√ß√µes em que h√° m√∫ltiplas formas
        v√°lidas de um dado aparecer ‚Äî por exemplo, resposta de API que pode ser <code>string</code> ou
        <code>null</code>, props opcionais ou tipos discriminados.</p>
      <pre><code class="language-ts">let status: &quot;carregando&quot; | &quot;sucesso&quot; | &quot;erro&quot;;
    
    status = &quot;carregando&quot;; // OK
    status = &quot;falha&quot;;      // ‚ùå Erro: &quot;falha&quot; n√£o √© um dos valores permitidos
    </code></pre>
      <p>Essa uni√£o tamb√©m pode ser usada entre tipos b√°sicos:</p>
      <pre><code class="language-ts">let valor: number | string;
    
    valor = 42;        // OK
    valor = &quot;quarenta&quot;; // OK
    valor = true;      // ‚ùå Erro
    </code></pre>
      <p>E em combina√ß√µes com arrays ou objetos:</p>
      <pre><code class="language-ts">type Resultado = { sucesso: true; dados: string[] } | { sucesso: false; erro: string };
    
    const resposta: Resultado = {
      sucesso: false,
      erro: &quot;Conex√£o perdida&quot;
    };
    </code></pre>
      <p>Esse padr√£o √© extremamente √∫til em TypeScript moderno, e muito comum em <strong>valida√ß√µes, parsing de JSON e
          controle de fluxo condicional</strong>.</p>
      <h3>Conclus√µes</h3>
      <p>Os <strong>tipos compostos</strong> s√£o ferramentas poderosas para modelar dados reais com precis√£o. Arrays
        permitem representar listas homog√™neas, tuplas permitem combinar valores heterog√™neos com significado
        posicional, e uni√µes trazem flexibilidade com seguran√ßa, permitindo expressar alternativas v√°lidas sem perder o
        controle do tipo.</p>
      <p>Esses recursos s√£o a ponte entre a simplicidade dos tipos primitivos e a expressividade de estruturas
        complexas. Nas pr√≥ximas se√ß√µes, vamos expandir ainda mais esse vocabul√°rio com <strong>objetos, interfaces,
          enums e tipos literais</strong>, que permitem modelar dom√≠nios de forma mais clara e robusta.</p>
      <hr>
      <h2>2.3 Objetos e Interfaces</h2>
      <p>Em TypeScript, al√©m de tipar valores primitivos, arrays e tuplas, √© essencial saber <strong>como declarar e
          estruturar objetos</strong> com seguran√ßa. Objetos est√£o no centro de praticamente toda aplica√ß√£o: representam
        entidades, props, respostas de APIs, estados de componentes e muito mais.</p>
      <p>Nesta se√ß√£o, veremos como <strong>tipar objetos diretamente</strong>, como <strong>criar interfaces
          reutiliz√°veis</strong>, e por que isso √© fundamental para organiza√ß√£o, clareza e manuten√ß√£o de projetos em
        React Native.</p>
      <h3>Tipagem direta de objetos</h3>
      <p>Voc√™ pode declarar objetos com tipos diretamente, utilizando anota√ß√µes inline:</p>
      <pre><code class="language-ts">const usuario: { nome: string; idade: number } = {
      nome: &quot;Camila&quot;,
      idade: 28
    };
    </code></pre>
      <p>Essa sintaxe funciona bem para objetos simples e usos pontuais. Por√©m, √† medida que os objetos crescem ou s√£o
        reutilizados em m√∫ltiplos lugares, o c√≥digo se torna repetitivo. √â a√≠ que entram as interfaces.</p>
      <h3>Interfaces</h3>
      <p>Uma <strong>interface</strong> √© uma forma de <strong>declarar a estrutura de um objeto com nome</strong>. Ela
        descreve quais propriedades o objeto deve ter e quais os tipos de cada uma.</p>
      <pre><code class="language-ts">interface Usuario {
      nome: string;
      idade: number;
    }
    
    const user: Usuario = {
      nome: &quot;Carlos&quot;,
      idade: 30
    };
    </code></pre>
      <p>Interfaces facilitam a leitura, promovem o reuso e servem como <strong>contrato entre diferentes partes do
          sistema</strong> ‚Äî por exemplo, entre o componente que recebe uma prop e aquele que a envia.</p>
      <h3>Interfaces em componentes React Native</h3>
      <pre><code class="language-tsx">interface Props {
      titulo: string;
      ativo: boolean;
    }
    
    const MeuBotao = ({ titulo, ativo }: Props) =&gt; {
      return (
        &lt;Button
          title={ativo ? titulo : &quot;Desativado&quot;}
          onPress={() =&gt; console.log(&quot;Clique&quot;)}
        /&gt;
      );
    };
    </code></pre>
      <p>Aqui, <code>Props</code> define de forma clara o que o componente espera. Se algu√©m tentar passar uma prop
        ausente ou com o tipo errado, o TypeScript acusar√° o erro imediatamente.</p>
      <h3>Propriedades opcionais</h3>
      <p>Voc√™ pode tornar propriedades <strong>opcionais</strong> com o operador <code>?</code>. Isso √© √∫til quando uma
        informa√ß√£o <strong>pode ou n√£o estar presente</strong> ‚Äî como valores default, flags ou dados carregados de
        forma ass√≠ncrona.</p>
      <pre><code class="language-ts">interface Produto {
      nome: string;
      preco: number;
      descricao?: string;
    }
    
    const item: Produto = {
      nome: &quot;Caderno&quot;,
      preco: 12.5
      // descri√ß√£o pode estar ausente
    };
    </code></pre>
      <p>Ao acessar uma propriedade opcional, o TypeScript exige que voc√™ lide com a possibilidade de ela ser
        <code>undefined</code>.</p>
      <h3>Leitura e seguran√ßa</h3>
      <p>Interfaces servem como documenta√ß√£o viva. IDEs como VSCode mostram os campos esperados, alertam sobre erros de
        tipo e oferecem autocompletar com base na interface.</p>
      <pre><code class="language-ts">function exibir(produto: Produto) {
      console.log(produto.nome);
      console.log(produto.descricao?.toUpperCase());
    }
    </code></pre>
      <p>Aqui usamos o <strong>operador de encadeamento opcional (<code>?.</code>)</strong> para acessar
        <code>descricao</code> apenas se ela existir, evitando erros em tempo de execu√ß√£o.</p>
      <h3>Interface x Type Alias</h3>
      <p>Voc√™ tamb√©m pode usar a palavra-chave <code>type</code> para criar tipos nomeados. Para objetos simples,
        <code>type</code> e <code>interface</code> s√£o equivalentes:</p>
      <pre><code class="language-ts">type Usuario = {
      nome: string;
      idade: number;
    };
    </code></pre>
      <p>Em geral:</p>
      <ul>
        <li><strong><code>interface</code></strong> √© mais apropriada para objetos e componentes, podendo ser
          <strong>extendida</strong>.</li>
        <li><strong><code>type</code></strong> √© mais flex√≠vel e permite criar <strong>uni√µes, interse√ß√µes, tipos
            literais, etc.</strong></li>
      </ul>
      <p>Exemplo de extens√£o com interface:</p>
      <pre><code class="language-ts">interface Pessoa {
      nome: string;
    }
    
    interface Funcionario extends Pessoa {
      salario: number;
    }
    
    const f: Funcionario = {
      nome: &quot;Joana&quot;,
      salario: 3000
    };
    </code></pre>
      <h3>Exemplo integrado: lista de tarefas</h3>
      <pre><code class="language-ts">interface Tarefa {
      id: number;
      titulo: string;
      concluida: boolean;
    }
    
    const tarefas: Tarefa[] = [
      { id: 1, titulo: &quot;Estudar&quot;, concluida: false },
      { id: 2, titulo: &quot;Exerc√≠cio&quot;, concluida: true }
    ];
    
    const pendentes = tarefas.filter(t =&gt; !t.concluida);
    </code></pre>
      <p>Esse padr√£o √© comum em apps de produtividade, listas de compras, controle de h√°bitos, etc. Tipar as tarefas com
        uma interface clara evita problemas como campos ausentes ou inconsistentes.</p>
      <h3>Conclus√µes</h3>
      <p>A tipagem de objetos com <strong>interfaces</strong> √© uma das maiores for√ßas do TypeScript. Ela melhora a
        organiza√ß√£o do c√≥digo, previne erros, facilita a leitura e reduz retrabalho. Em aplica√ß√µes React Native,
        interfaces s√£o indispens√°veis para tipar props de componentes, estados de tela, dados externos e objetos de
        neg√≥cio.</p>
      <p>A seguir, veremos como trabalhar com <strong>enums, tipos literais e valida√ß√£o por valor</strong>, para tornar
        nossas estruturas ainda mais expressivas e seguras.</p>
      <hr>
      <h2>2.4 Enums, Tipos Literais e Discrimina√ß√£o de Tipos</h2>
      <p>√Ä medida que nossas aplica√ß√µes crescem, surgem casos em que precisamos <strong>restringir o valor de uma
          vari√°vel a um conjunto espec√≠fico de op√ß√µes v√°lidas</strong> ‚Äî por exemplo, o status de uma tarefa, a
        categoria de um produto ou o papel de um usu√°rio no sistema.</p>
      <p>Em TypeScript, isso pode ser feito de forma <strong>segura e clara</strong> por meio de tr√™s mecanismos
        complementares:</p>
      <ul>
        <li><strong>Enums</strong> (enumeradores)</li>
        <li><strong>Tipos literais</strong></li>
        <li><strong>Discrimina√ß√£o de tipos</strong> (ou tipos ‚Äútagueados‚Äù)</li>
      </ul>
      <p>Esses recursos ajudam a representar regras de neg√≥cio, validar dados e garantir que nossos objetos sigam
        formatos v√°lidos ‚Äî tudo com suporte de autocompletar e checagem em tempo de desenvolvimento.</p>
      <h3>Enums (Enumeradores)</h3>
      <p>Enums s√£o estruturas que <strong>agrupam valores nomeados</strong> e podem ser usados para representar
        conjuntos fechados, como estados ou categorias.</p>
      <h4>Enum num√©rico</h4>
      <pre><code class="language-ts">enum Status {
      Pendente,
      EmAndamento,
      Concluida
    }
    
    let estado: Status = Status.EmAndamento;
    console.log(estado); // 1
    </code></pre>
      <p>Os valores atribu√≠dos s√£o num√©ricos por padr√£o (<code>0</code>, <code>1</code>, <code>2</code>‚Ä¶), mas podemos
        definir valores literais se preferirmos mais legibilidade:</p>
      <h4>Enum com strings</h4>
      <pre><code class="language-ts">enum PapelUsuario {
      Admin = &quot;ADMIN&quot;,
      Editor = &quot;EDITOR&quot;,
      Leitor = &quot;LEITOR&quot;
    }
    
    const permissao: PapelUsuario = PapelUsuario.Editor;
    </code></pre>
      <p>Esse padr√£o √© √∫til para tokens de permiss√£o, rotas, filtros e campos que precisam ser persistidos como texto ‚Äî
        por exemplo, em um banco de dados ou localStorage.</p>
      <h4>Uso com objetos e componentes</h4>
      <pre><code class="language-tsx">interface Usuario {
      nome: string;
      papel: PapelUsuario;
    }
    
    function podeEditar(usuario: Usuario): boolean {
      return usuario.papel === PapelUsuario.Admin || usuario.papel === PapelUsuario.Editor;
    }
    </code></pre>
      <h3>Tipos Literais</h3>
      <p>Tipos literais restringem o valor de uma vari√°vel a <strong>valores exatos</strong>, usando <strong>strings,
          n√∫meros ou booleanos fixos</strong>.</p>
      <pre><code class="language-ts">type Estado = &quot;pendente&quot; | &quot;em_andamento&quot; | &quot;concluida&quot;;
    
    let status: Estado = &quot;pendente&quot;;
    
    status = &quot;concluida&quot;; // ‚úÖ OK
    status = &quot;cancelada&quot;; // ‚ùå Erro
    </code></pre>
      <p>Esse recurso √© especialmente √∫til quando o conjunto de valores v√°lidos √© pequeno e n√£o h√° necessidade de um
        enum separado. Ele √© <strong>mais leve</strong>, <strong>mais f√°cil de combinar com tipos de uni√£o</strong> e
        <strong>muito utilizado em APIs e tipos de props</strong>.</p>
      <h3>Discrimina√ß√£o de Tipos (Tipos Tagueados)</h3>
      <p>Quando usamos <strong>tipos literais como identificadores internos</strong> de objetos, podemos criar
        estruturas que permitem ao TypeScript <strong>inferir automaticamente os campos dispon√≠veis</strong> com base em
        um valor.</p>
      <p>Esse padr√£o √© conhecido como <strong>discriminated union</strong> (uni√£o discriminada) ou <strong>tagged
          union</strong>.</p>
      <h4>Exemplo: respostas de API</h4>
      <pre><code class="language-ts">type Sucesso = { tipo: &quot;sucesso&quot;; dados: string[] };
    type Erro = { tipo: &quot;erro&quot;; mensagem: string };
    
    type Resultado = Sucesso | Erro;
    
    function processar(r: Resultado) {
      if (r.tipo === &quot;sucesso&quot;) {
        console.log(&quot;Dados:&quot;, r.dados);
      } else {
        console.log(&quot;Erro:&quot;, r.mensagem);
      }
    }
    </code></pre>
      <p>Esse padr√£o √© muito poderoso porque permite que o TypeScript <strong>refine automaticamente os tipos
          dispon√≠veis</strong> de acordo com a verifica√ß√£o do valor de <code>tipo</code>.</p>
      <h3>Comparando Enum e Tipo Literal</h3>
      <table>
        <thead>
          <tr>
            <th>Recurso</th>
            <th>Quando usar</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><code>enum</code></td>
            <td>Quando h√° necessidade de valores nomeados reutiliz√°veis ou compat√≠veis com outras linguagens</td>
          </tr>
          <tr>
            <td><code>type</code> com literal</td>
            <td>Quando o conjunto de valores √© simples e direto, sem l√≥gica associada</td>
          </tr>
        </tbody>
      </table>
      <p>Exemplo com enum:</p>
      <pre><code class="language-ts">enum Tema {
      Claro = &quot;claro&quot;,
      Escuro = &quot;escuro&quot;
    }
    </code></pre>
      <p>Exemplo com tipo literal:</p>
      <pre><code class="language-ts">type Tema = &quot;claro&quot; | &quot;escuro&quot;;
    </code></pre>
      <p>No contexto do React Native, tipos literais costumam ser preferidos para props e estados locais, enquanto enums
        s√£o √∫teis para representar <strong>pap√©is de usu√°rio, tipos de entidade, modos de opera√ß√£o ou configura√ß√µes
          globais</strong>.</p>
      <h3>Conclus√µes</h3>
      <p>O uso de <strong>enums, tipos literais e estruturas discriminadas</strong> permite que o TypeScript funcione
        como uma <strong>camada de valida√ß√£o sem√¢ntica</strong> sobre o JavaScript. Isso facilita a modelagem de regras
        de neg√≥cio, evita valores inv√°lidos, e fornece documenta√ß√£o autom√°tica por meio da pr√≥pria defini√ß√£o dos tipos.
      </p>
      <p>Vamos, agora, aprofundar o uso de <strong>generics, utilit√°rios de tipo e boas pr√°ticas de organiza√ß√£o</strong>
        para garantir que nossos tipos se mantenham reutiliz√°veis, consistentes e f√°ceis de evoluir ao longo do tempo.
      </p>
      <hr>
      <h2>2.5 Generics: Reutiliza√ß√£o com Seguran√ßa</h2>
      <p><strong>Generics</strong> s√£o um dos recursos mais poderosos do TypeScript, pois permitem escrever
        <strong>c√≥digo reutiliz√°vel e ao mesmo tempo fortemente tipado</strong>. Eles resolvem um problema cl√°ssico:
        como criar <strong>fun√ß√µes, interfaces ou classes</strong> que funcionem com <strong>diferentes tipos de
          dados</strong>, mas <strong>sem abrir m√£o da verifica√ß√£o est√°tica</strong>?</p>
      <p>Essa funcionalidade √© especialmente √∫til em fun√ß√µes utilit√°rias, hooks personalizados, componentes que lidam
        com dados gen√©ricos e at√© na modelagem de estruturas como listas, formul√°rios e respostas de API.</p>
      <h3>Motiva√ß√£o: o problema do <code>any</code></h3>
      <p>Suponha que voc√™ deseje criar uma fun√ß√£o para retornar o primeiro item de um array:</p>
      <pre><code class="language-ts">function primeiro(arr: any[]) {
      return arr[0];
    }
    </code></pre>
      <p>Essa fun√ß√£o funciona ‚Äî mas como usamos <code>any</code>, o TypeScript <strong>perde completamente a no√ß√£o do
          tipo</strong> dos dados. Isso anula os benef√≠cios da tipagem est√°tica:</p>
      <pre><code class="language-ts">const nome = primeiro([&quot;Ana&quot;, &quot;Carlos&quot;]);
    nome.toUpperCase(); // ‚ùå Erro s√≥ em tempo de execu√ß√£o
    </code></pre>
      <h3>Solu√ß√£o: uso de Generics</h3>
      <p>Generics nos permitem <strong>declarar tipos como vari√°veis de tipo</strong>, e depois <strong>substitu√≠-los de
          forma autom√°tica</strong> com base no uso real da fun√ß√£o.</p>
      <pre><code class="language-ts">function primeiro&lt;T&gt;(arr: T[]): T {
      return arr[0];
    }
    </code></pre>
      <ul>
        <li><code>T</code> √© um <strong>par√¢metro de tipo</strong>.</li>
        <li><code>T[]</code> indica que a fun√ß√£o recebe um array de elementos do tipo T.</li>
        <li>A fun√ß√£o retorna um valor do mesmo tipo T.</li>
      </ul>
      <p>Agora, ao usar a fun√ß√£o, o TypeScript <strong>infere automaticamente</strong> o tipo com base nos argumentos:
      </p>
      <pre><code class="language-ts">const nome = primeiro([&quot;Ana&quot;, &quot;Carlos&quot;]); // T √© string
    const numero = primeiro([10, 20, 30]);     // T √© number
    
    nome.toUpperCase(); // ‚úÖ OK
    numero.toFixed(2);  // ‚úÖ OK
    </code></pre>
      <p>A fun√ß√£o se tornou <strong>gen√©rica</strong>, mas continua <strong>tipada com precis√£o</strong> ‚Äî um equil√≠brio
        perfeito entre flexibilidade e seguran√ßa.</p>
      <h3>Generics com Objetos</h3>
      <p>Podemos aplicar generics para fun√ß√µes que manipulam objetos sem perder informa√ß√£o:</p>
      <pre><code class="language-ts">function extrairChave&lt;T, K extends keyof T&gt;(obj: T, chave: K): T[K] {
      return obj[chave];
    }
    
    const usuario = { nome: &quot;Luana&quot;, idade: 30 };
    
    const valor = extrairChave(usuario, &quot;nome&quot;); // valor: string
    </code></pre>
      <ul>
        <li><code>T</code> representa o tipo do objeto.</li>
        <li><code>K</code> representa uma <strong>chave v√°lida dentro de T</strong>.</li>
        <li><code>T[K]</code> representa o tipo do valor correspondente √† chave.</li>
      </ul>
      <p>Esse padr√£o √© extremamente √∫til em bibliotecas, hooks e valida√ß√µes gen√©ricas.</p>
      <h3>Generics com React Hooks</h3>
      <p>Ao criar hooks personalizados, usar generics permite que eles funcionem com qualquer tipo de dado:</p>
      <pre><code class="language-ts">function useLista&lt;T&gt;(inicial: T[]) {
      const [itens, setItens] = useState&lt;T[]&gt;(inicial);
    
      function adicionar(item: T) {
        setItens(prev =&gt; [...prev, item]);
      }
    
      return { itens, adicionar };
    }
    </code></pre>
      <p>Uso:</p>
      <pre><code class="language-tsx">const { itens, adicionar } = useLista&lt;string&gt;([&quot;Ol√°&quot;, &quot;Oi&quot;]);
    adicionar(&quot;Bom dia&quot;); // ‚úÖ OK
    
    const numeros = useLista&lt;number&gt;([1, 2, 3]);
    numeros.adicionar(4);
    </code></pre>
      <p>O hook continua gen√©rico, mas com <strong>tipagem total</strong> em cada uso.</p>
      <h3>Generics em Interfaces</h3>
      <p>Tamb√©m √© poss√≠vel criar <strong>interfaces gen√©ricas</strong>, que se adaptam ao tipo de dado fornecido:</p>
      <pre><code class="language-ts">interface ApiResponse&lt;T&gt; {
      sucesso: boolean;
      dados: T;
    }
    
    const resposta1: ApiResponse&lt;string[]&gt; = {
      sucesso: true,
      dados: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
    };
    
    const resposta2: ApiResponse&lt;{ id: number; nome: string }&gt; = {
      sucesso: true,
      dados: { id: 1, nome: &quot;Produto&quot; }
    };
    </code></pre>
      <p>Esse padr√£o √© especialmente √∫til para representar <strong>respostas de APIs REST</strong>, <strong>resultados
          paginados</strong>, <strong>estados gen√©ricos</strong>, entre outros.</p>
      <h3>Conclus√µes</h3>
      <p><strong>Generics</strong> permitem escrever c√≥digo flex√≠vel <strong>sem sacrificar a seguran√ßa de
          tipos</strong>. Eles s√£o fundamentais para criar fun√ß√µes, hooks, interfaces e componentes
        <strong>reutiliz√°veis e confi√°veis</strong>, reduzindo repeti√ß√£o e erros. Em React Native com TypeScript, seu
        uso √© altamente recomendado ‚Äî seja em listas de dados, estados compartilhados, componentes de formul√°rio ou
        APIs.</p>
      <p>Nas pr√≥ximas se√ß√µes, vamos conhecer <strong>utilit√°rios de tipos</strong> que tornam essas estruturas ainda
        mais expressivas, como <code>Partial</code>, <code>Pick</code>, <code>Omit</code>, <code>Record</code> e
        <code>Readonly</code>.</p>
      <hr>
      <h2>2.6 Utilit√°rios de Tipo (Utility Types)</h2>
      <p>O TypeScript fornece um conjunto de <strong>utilit√°rios prontos</strong>, conhecidos como <strong>utility
          types</strong>, que permitem <strong>transformar, adaptar ou derivar tipos existentes</strong> de maneira
        segura e sem repeti√ß√£o.</p>
      <p>Esses utilit√°rios s√£o especialmente √∫teis para <strong>refatorar c√≥digo</strong>, <strong>criar varia√ß√µes
          parciais ou restritas de objetos</strong>, e <strong>gerar estruturas auxiliares</strong> que mantenham a
        consist√™ncia do sistema. Eles s√£o amplamente usados em projetos React/React Native ‚Äî seja para definir props
        parciais, omitir campos sens√≠veis, lidar com formul√°rios ou construir APIs tipadas.</p>
      <p>A seguir, vamos ver os mais importantes e como us√°-los na pr√°tica.</p>
      <h3><code>Partial&lt;T&gt;</code></h3>
      <p>Converte todas as propriedades de um tipo para <strong>opcionais</strong>.</p>
      <pre><code class="language-ts">interface Usuario {
      nome: string;
      email: string;
      idade: number;
    }
    
    const atualizacao: Partial&lt;Usuario&gt; = {
      email: &quot;novo@email.com&quot;
    };
    </code></pre>
      <p>Esse padr√£o √© comum ao <strong>atualizar dados</strong> parcialmente, como num formul√°rio, num
        <code>PATCH</code>, ou em um <code>setState</code>.</p>
      <h3><code>Required&lt;T&gt;</code></h3>
      <p>Converte todas as propriedades de um tipo para <strong>obrigat√≥rias</strong> (oposto do <code>Partial</code>).
      </p>
      <pre><code class="language-ts">interface Config {
      modo?: string;
      verbose?: boolean;
    }
    
    const c: Required&lt;Config&gt; = {
      modo: &quot;escuro&quot;,
      verbose: true
    };
    </code></pre>
      <p>√ötil quando queremos for√ßar o preenchimento de dados em contextos espec√≠ficos, como em um componente que
        depende de uma configura√ß√£o completa.</p>
      <h3><code>Readonly&lt;T&gt;</code></h3>
      <p>Torna todas as propriedades de um tipo <strong>imut√°veis</strong> (n√£o podem ser reatribu√≠das).</p>
      <pre><code class="language-ts">interface Produto {
      nome: string;
      preco: number;
    }
    
    const p: Readonly&lt;Produto&gt; = {
      nome: &quot;Caderno&quot;,
      preco: 10
    };
    
    p.preco = 15; // ‚ùå Erro: n√£o √© poss√≠vel modificar um campo readonly
    </code></pre>
      <p>Esse utilit√°rio √© √∫til para evitar muta√ß√µes acidentais ‚Äî por exemplo, ao trabalhar com objetos que representam
        dados fixos ou retornos de fun√ß√µes puras.</p>
      <h3><code>Pick&lt;T, K&gt;</code></h3>
      <p>Cria um tipo que <strong>extrai um subconjunto de propriedades</strong> de outro tipo.</p>
      <pre><code class="language-ts">interface Usuario {
      id: number;
      nome: string;
      senha: string;
    }
    
    type UsuarioPublico = Pick&lt;Usuario, &quot;id&quot; | &quot;nome&quot;&gt;;
    
    const u: UsuarioPublico = {
      id: 1,
      nome: &quot;Camila&quot;
    };
    </code></pre>
      <p>Muito √∫til para <strong>filtrar campos seguros</strong> que podem ser exibidos ou enviados ao front-end.</p>
      <h3><code>Omit&lt;T, K&gt;</code></h3>
      <p>Faz o oposto de <code>Pick</code>: <strong>remove</strong> propriedades do tipo original.</p>
      <pre><code class="language-ts">type UsuarioSemSenha = Omit&lt;Usuario, &quot;senha&quot;&gt;;
    </code></pre>
      <p>Esse padr√£o √© ideal quando voc√™ quer <strong>reaproveitar uma estrutura</strong>, mas excluir informa√ß√µes
        sens√≠veis ou desnecess√°rias.</p>
      <h3><code>Record&lt;K, T&gt;</code></h3>
      <p>Cria um tipo de <strong>objeto indexado</strong>, em que todas as chaves <code>K</code> mapeiam para o tipo
        <code>T</code>.</p>
      <pre><code class="language-ts">type Dias = &quot;seg&quot; | &quot;ter&quot; | &quot;qua&quot;;
    
    const agenda: Record&lt;Dias, string&gt; = {
      seg: &quot;reuni√£o&quot;,
      ter: &quot;aula&quot;,
      qua: &quot;livre&quot;
    };
    </code></pre>
      <p>Muito √∫til para tabelas de lookup, dicion√°rios de mensagens, mapeamento de √≠cones ou rotas de navega√ß√£o.</p>
      <h3>Exemplo pr√°tico em React Native</h3>
      <p>Imagine um hook que recebe uma fun√ß√£o de atualiza√ß√£o de perfil parcial:</p>
      <pre><code class="language-ts">interface Perfil {
      nome: string;
      bio: string;
      avatar: string;
    }
    
    function atualizarPerfil(dados: Partial&lt;Perfil&gt;) {
      // envia apenas os campos alterados para a API
    }
    </code></pre>
      <p>E em um componente de listagem, voc√™ pode esconder campos sens√≠veis com <code>Omit</code>:</p>
      <pre><code class="language-ts">type UsuarioSemAvatar = Omit&lt;Perfil, &quot;avatar&quot;&gt;;
    </code></pre>
      <p>Ou gerar uma estrutura de estado com <code>Readonly</code> para garantir que os dados n√£o sejam reatribu√≠dos
        acidentalmente.</p>
      <h3>Conclus√µes</h3>
      <p>Os <strong>utility types</strong> do TypeScript economizam tempo e evitam duplica√ß√£o, permitindo criar
        <strong>tipos derivados com seguran√ßa</strong>. Eles se tornam ainda mais poderosos quando combinados com
        generics e interfaces ‚Äî e s√£o ferramentas indispens√°veis para aplica√ß√µes profissionais com React Native.</p>
      <p>Combinados, esses recursos nos permitem modelar dados com precis√£o, adaptar estruturas conforme o contexto e
        manter a consist√™ncia do sistema mesmo √† medida que ele cresce.</p>
      <hr>
      <h2>3. Resolu√ß√£o dos Exerc√≠cios da Aula 01</h2>
      <p>Para consolidar o entendimento dos conceitos abordados at√© aqui ‚Äî como desestrutura√ß√£o, arrow functions,
        operadores spread/rest, m√©todos de array e fundamentos do TypeScript ‚Äî vamos agora retomar os exerc√≠cios
        propostos ao final da Aula 01. A ideia √© analisar passo a passo suas resolu√ß√µes, destacando como as pr√°ticas de
        JavaScript e os recursos de tipagem do TypeScript contribuem para um c√≥digo mais alinhado com o estilo adotado
        no desenvolvimento com React Native. üòä</p>
      <h3>‚úÖ Exerc√≠cio 01 ‚Äì <code>arrayUtils.js</code></h3>
      <p>Este exerc√≠cio prop√¥s a an√°lise de tr√™s fun√ß√µes utilit√°rias para manipula√ß√£o de arrays: <code>unique</code>,
        <code>groupBy</code> e <code>sumBy</code>. Vamos agora revis√°-las e entend√™-las, relacionando sua l√≥gica com os
        conceitos trabalhados nesta segunda aula.</p>
      <h4>üìå Fun√ß√£o <code>unique</code></h4>
      <pre><code class="language-js">export const unique = arr =&gt; [...new Set(arr)];
    </code></pre>
      <p>A fun√ß√£o <code>unique</code> recebe um array e retorna um novo array contendo apenas os valores √∫nicos. Isso √©
        feito com o uso da estrutura de dados <code>Set</code>, que elimina automaticamente os elementos duplicados, e
        do operador <strong>spread (<code>...</code>)</strong>, que expande os valores do <code>Set</code> de volta em
        um array. Trata-se de uma abordagem declarativa e imut√°vel para filtragem de duplicatas.</p>
      <p>Agora imagine, por exemplo, que voc√™ tem uma lista de nomes que podem conter repeti√ß√µes:</p>
      <pre><code class="language-js">const nomes = [&quot;Ana&quot;, &quot;Carlos&quot;, &quot;Ana&quot;, &quot;Jo√£o&quot;, &quot;Carlos&quot;];
    const nomesUnicos = unique(nomes);
    
    console.log(nomesUnicos);
    // Sa√≠da: [&quot;Ana&quot;, &quot;Carlos&quot;, &quot;Jo√£o&quot;]
    </code></pre>
      <p>Ao usarmos a fun√ß√£o <code>unique</code>, a estrutura <code>Set</code> elimina automaticamente os elementos
        duplicados, e o operador spread <code>...</code> cria um novo array com os valores √∫nicos. Esse padr√£o √© √∫til
        para garantir que elementos repetidos sejam removidos de forma simples.</p>
      <h4>üìå Fun√ß√£o <code>groupBy</code></h4>
      <pre><code class="language-js">export const groupBy = (arr, key) =&gt;
      arr.reduce((acc, obj) =&gt; {
        (acc[obj[key]] = acc[obj[key]] || []).push(obj);
        return acc;
      }, {});
    </code></pre>
      <p>A fun√ß√£o <code>groupBy</code> agrupa os elementos do array de acordo com uma propriedade informada. Isso √©
        feito com o m√©todo <code>reduce</code>, que constr√≥i um novo objeto onde cada chave representa um grupo e os
        valores s√£o arrays de objetos correspondentes. A constru√ß√£o condicional
        <code>acc[obj[key]] = acc[obj[key]] || []</code> assegura que a chave exista antes de fazer o <code>push</code>.
        Essa √© uma aplica√ß√£o t√≠pica do <code>reduce</code> para transforma√ß√£o de dados estruturados.</p>
      <p>Para entender o funcionamento de forma mais concreta, suponha que temos um array de objetos representando
        produtos, e queremos agrup√°-los por categoria:</p>
      <pre><code class="language-js">const produtos = [
      { nome: &quot;Banana&quot;, categoria: &quot;Frutas&quot; },
      { nome: &quot;Ma√ß√£&quot;, categoria: &quot;Frutas&quot; },
      { nome: &quot;Cenoura&quot;, categoria: &quot;Legumes&quot; },
      { nome: &quot;Alface&quot;, categoria: &quot;Verduras&quot; },
      { nome: &quot;Br√≥colis&quot;, categoria: &quot;Verduras&quot; }
    ];
    </code></pre>
      <p>Se aplicarmos a fun√ß√£o <code>groupBy</code> passando o array <code>produtos</code> e a chave
        <code>&quot;categoria&quot;</code>:</p>
      <pre><code class="language-js">const agrupados = groupBy(produtos, &quot;categoria&quot;);
    console.log(agrupados);
    </code></pre>
      <p>O resultado ser√°:</p>
      <pre><code class="language-js">{
      Frutas: [
        { nome: &quot;Banana&quot;, categoria: &quot;Frutas&quot; },
        { nome: &quot;Ma√ß√£&quot;, categoria: &quot;Frutas&quot; }
      ],
      Legumes: [
        { nome: &quot;Cenoura&quot;, categoria: &quot;Legumes&quot; }
      ],
      Verduras: [
        { nome: &quot;Alface&quot;, categoria: &quot;Verduras&quot; },
        { nome: &quot;Br√≥colis&quot;, categoria: &quot;Verduras&quot; }
      ]
    }
    </code></pre>
      <p>Assim, o passo a passo da fun√ß√£o ser√°:</p>
      <ol>
        <li>Come√ßa com um objeto vazio <code>{}</code>.</li>
        <li>Para cada item do array, verifica o valor da chave <code>categoria</code>.</li>
        <li>Se esse valor ainda n√£o existir como chave no acumulador <code>acc</code>, cria uma nova entrada com array
          vazio.</li>
        <li>Adiciona o objeto atual ao array correspondente.</li>
      </ol>
      <p>A linha cr√≠tica √© esta:</p>
      <pre><code class="language-js">acc[obj[key]] = acc[obj[key]] || [];
    </code></pre>
      <p>Ela garante que, se <code>acc[obj[key]]</code> for <code>undefined</code>, ele ser√° inicializado como
        <code>[]</code> antes de receber <code>.push(obj)</code>. </p>
      <h4>üìå Fun√ß√£o <code>sumBy</code></h4>
      <pre><code class="language-js">export const sumBy = (arr, key) =&gt;
      arr.reduce((total, obj) =&gt; total + (obj[key] ?? 0), 0);
    </code></pre>
      <p>A fun√ß√£o <code>sumBy</code> soma os valores de uma determinada propriedade em um array de objetos. Utiliza o
        <code>reduce</code> para acumular o total e o operador de <strong>coalesc√™ncia nula (<code>??</code>)</strong>
        para lidar com casos em que o valor da propriedade pode ser <code>undefined</code> ou <code>null</code>,
        evitando falhas silenciosas e garantindo que a soma seja precisa.</p>
      <p>Imagine uma lista de produtos e voc√™ quer somar todos os pre√ßos:</p>
      <pre><code class="language-js">const produtos = [
      { nome: &quot;Caneta&quot;, preco: 2.5 },
      { nome: &quot;Caderno&quot;, preco: 15 },
      { nome: &quot;Borracha&quot; } // pre√ßo ausente
    ];
    
    const total = sumBy(produtos, &quot;preco&quot;);
    
    console.log(total);
    // Sa√≠da: 17.5
    </code></pre>
      <p>A fun√ß√£o percorre os objetos com <code>reduce</code>, somando os valores da chave <code>preco</code>. Caso a
        chave esteja ausente, o operador de coalesc√™ncia nula <code>??</code> garante que o valor somado ser√°
        <code>0</code>. </p>
      <h4>‚úÖ Em s√≠ntese</h4>
      <p>A resolu√ß√£o deste exerc√≠cio aplica alguns dos conceitos centrais do JavaScript que foram revisados nesta aula:
        o <strong>operador spread</strong>, o uso de <strong>fun√ß√µes arrow</strong>, a <strong>imutabilidade</strong> na
        transforma√ß√£o de dados, o poder expressivo do m√©todo <strong>reduce</strong>, al√©m da <strong>acessibilidade
          din√¢mica de propriedades</strong> com <code>obj[key]</code>. Al√©m disso, vimos a aplica√ß√£o da
        <strong>coalesc√™ncia nula (<code>??</code>)</strong> como forma de garantir seguran√ßa na leitura de
        propriedades.</p>
      <p>Essas tr√™s fun√ß√µes tamb√©m exemplificam o paradigma da <strong>programa√ß√£o funcional</strong>, pois operam sobre
        dados de forma pura e previs√≠vel, retornando novos valores sem modificar os originais. </p>
      <p>Sim, eu sei que n√£o hav√≠amos visto nada disso quando pedi os exerc√≠cios a voc√™s ‚Äî mas, agora, com a explica√ß√£o,
        fica mais f√°cil entender e relacionar as ideias, n√©? Essa √© justamente a proposta: apresentar desafios e, em
        seguida, esclarecer os fundamentos. ü§©</p>
      <hr>
      <h3>‚úÖ Exerc√≠cio 02 ‚Äì Migra√ß√£o para <code>arrayUtils.ts</code></h3>
      <p>Neste exerc√≠cio, o desafio foi migrar as fun√ß√µes utilit√°rias do JavaScript puro para uma vers√£o <strong>tipada
          com TypeScript</strong>, utilizando recursos como generics, infer√™ncia de tipos e valida√ß√£o est√°tica. Vamos
        revisar as vers√µes finais de cada fun√ß√£o, relacionando-as com os conceitos apresentados nesta segunda aula.</p>
      <h4>üìå Fun√ß√£o <code>unique</code></h4>
      <pre><code class="language-ts">export const unique = &lt;T&gt;(arr: T[]): T[] =&gt; [...new Set(arr)];
    </code></pre>
      <p>A fun√ß√£o <code>unique</code> tipada com TypeScript segue a mesma l√≥gica da vers√£o anterior, mas agora utiliza o
        tipo gen√©rico <code>&lt;T&gt;</code> para garantir que o array recebido e o array retornado mantenham o mesmo
        tipo. Isso permite que a fun√ß√£o seja reutiliz√°vel com qualquer tipo de dado ‚Äî seja <code>string</code>,
        <code>number</code>, ou at√© mesmo objetos complexos.</p>
      <p>Exemplo com strings:</p>
      <pre><code class="language-ts">const nomes = [&quot;Ana&quot;, &quot;Carlos&quot;, &quot;Ana&quot;, &quot;Jo√£o&quot;];
    const nomesUnicos = unique(nomes);
    
    console.log(nomesUnicos);
    // Sa√≠da: [&quot;Ana&quot;, &quot;Carlos&quot;, &quot;Jo√£o&quot;]
    </code></pre>
      <p>Aqui, o TypeScript infere corretamente que <code>nomesUnicos</code> √© um <code>string[]</code>, e fornece
        autocompletar e valida√ß√£o de tipos.</p>
      <h4>üìå Fun√ß√£o <code>groupBy</code></h4>
      <pre><code class="language-ts">export const groupBy = &lt;T, K extends keyof T&gt;(
      arr: T[],
      key: K
    ): Record&lt;string, T[]&gt; =&gt;
      arr.reduce((acc, obj) =&gt; {
        const k = String(obj[key]);
        acc[k] = acc[k] || [];
        acc[k].push(obj);
        return acc;
      }, {} as Record&lt;string, T[]&gt;);
    </code></pre>
      <p>A fun√ß√£o <code>groupBy</code> agora est√° tipada com dois par√¢metros gen√©ricos: <code>T</code>, representando o
        tipo dos objetos do array, e <code>K</code>, que representa a chave usada para agrupar. O uso de
        <code>K extends keyof T</code> garante que apenas chaves v√°lidas do tipo <code>T</code> possam ser utilizadas,
        evitando erros comuns.</p>
      <p>Suponha que temos um array de produtos e queremos agrup√°-los por categoria:</p>
      <pre><code class="language-ts">type Produto = { nome: string; categoria: string };
    
    const produtos: Produto[] = [
      { nome: &quot;Banana&quot;, categoria: &quot;Frutas&quot; },
      { nome: &quot;Ma√ß√£&quot;, categoria: &quot;Frutas&quot; },
      { nome: &quot;Cenoura&quot;, categoria: &quot;Legumes&quot; }
    ];
    
    const agrupados = groupBy(produtos, &quot;categoria&quot;);
    
    console.log(agrupados);
    </code></pre>
      <p>Sa√≠da esperada:</p>
      <pre><code class="language-ts">{
      Frutas: [
        { nome: &quot;Banana&quot;, categoria: &quot;Frutas&quot; },
        { nome: &quot;Ma√ß√£&quot;, categoria: &quot;Frutas&quot; }
      ],
      Legumes: [
        { nome: &quot;Cenoura&quot;, categoria: &quot;Legumes&quot; }
      ]
    }
    </code></pre>
      <p>A tipagem com <code>Record&lt;string, T[]&gt;</code> informa ao compilador e ao desenvolvedor que o retorno
        ser√° um objeto onde as chaves s√£o strings e os valores s√£o arrays de elementos do tipo <code>T</code>.</p>
      <h4>üìå Fun√ß√£o <code>sumBy</code></h4>
      <pre><code class="language-ts">export const sumBy = &lt;T&gt;(arr: T[], key: keyof T): number =&gt;
      arr.reduce((total, obj) =&gt; total + (Number(obj[key]) || 0), 0);
    </code></pre>
      <p>A fun√ß√£o <code>sumBy</code> foi tipada para aceitar qualquer tipo de objeto <code>T</code>, mas exige que a
        <code>key</code> seja uma propriedade v√°lida (<code>keyof T</code>). A convers√£o expl√≠cita com
        <code>Number()</code> garante que o retorno sempre seja num√©rico, mesmo que a propriedade contenha
        <code>string</code> ou <code>undefined</code>.</p>
      <p>Suponha que temos um array de despesas:</p>
      <pre><code class="language-ts">type Despesa = { item: string; valor?: number };
    
    const despesas: Despesa[] = [
      { item: &quot;Transporte&quot;, valor: 20 },
      { item: &quot;Almo√ßo&quot;, valor: 35 },
      { item: &quot;Caf√©&quot; }
    ];
    
    const total = sumBy(despesas, &quot;valor&quot;);
    
    console.log(total);
    // Sa√≠da: 55
    </code></pre>
      <p>Mesmo com uma propriedade ausente (<code>valor</code>), a fun√ß√£o continua funcionando com seguran√ßa gra√ßas ao
        uso de <code>Number(obj[key]) || 0</code>.</p>
      <h4>‚úÖ Em s√≠ntese</h4>
      <p>A migra√ß√£o para TypeScript refor√ßa os conceitos de <strong>tipagem gen√©rica</strong>, <strong>uso de
          <code>keyof</code> e <code>extends</code> para valida√ß√£o de chaves</strong>, e o emprego de <strong>utility
          types</strong> como <code>Record</code>. Al√©m disso, os exemplos mostraram como o TypeScript melhora a
        experi√™ncia do desenvolvedor, fornecendo valida√ß√£o est√°tica, sugest√µes autom√°ticas e prote√ß√£o contra erros
        comuns.</p>
      <p>Com isso, n√£o apenas refor√ßamos os recursos da linguagem, mas tamb√©m mantivemos o compromisso com
        <strong>fun√ß√µes puras, reutiliz√°veis e previs√≠veis</strong> ‚Äî um dos pilares da programa√ß√£o funcional que
        estamos adotando com React Native.</p>
      <p>E sim, como aconteceu no exerc√≠cio anterior, talvez no momento da proposta as tipagens parecessem desafiadoras
        ‚Äî mas agora que revisitamos os fundamentos, come√ßa a fazer mais sentido, n√©? </p>
      <hr>
      <h2>‚úÖ Exerc√≠cio 03 ‚Äì <code>pokedex.ts</code>: Consulta √† Pok√©API via CLI</h2>
      <p>Neste terceiro exerc√≠cio, desenvolvemos uma pequena aplica√ß√£o de linha de comando (CLI) em TypeScript para
        consultar dados de um Pok√©mon usando a <a href="https://pokeapi.co/">Pok√©API</a>. A proposta serviu para aplicar
        diversos conceitos de JavaScript moderno e TypeScript em um contexto pr√°tico e mais pr√≥ximo do &quot;mundo
        real&quot;: leitura de argumentos via terminal, chamadas ass√≠ncronas com <code>fetch</code>, tratamento de
        exce√ß√µes, manipula√ß√£o de dados com <code>.map()</code> e <code>.join()</code>, al√©m da organiza√ß√£o do c√≥digo em
        fun√ß√µes puras e tipadas.</p>
      <h4>üìå Etapa 1 ‚Äì Captura do argumento via terminal</h4>
      <pre><code class="language-ts">const entrada = process.argv[2];
    
    if (!entrada) {
      console.log(&quot;‚ùå Informe um nome ou ID de Pok√©mon.&quot;);
      process.exit(1);
    }
    </code></pre>
      <p>Utilizamos o array <code>process.argv</code> para capturar o valor passado na linha de comando (por exemplo:
        <code>pikachu</code>). A verifica√ß√£o <code>if (!entrada)</code> garante que o programa s√≥ continue se o usu√°rio
        fornecer um argumento v√°lido.</p>
      <h4>üìå Etapa 2 ‚Äì Fun√ß√£o principal com <code>async/await</code></h4>
      <pre><code class="language-ts">async function buscarPokemon(idOuNome: string): Promise&lt;void&gt; {
      const url = `https://pokeapi.co/api/v2/pokemon/${idOuNome.toLowerCase()}`;
    
      try {
        const resposta = await fetch(url);
    
        if (!resposta.ok) {
          if (resposta.status === 404) {
            console.log(&quot;‚ùå Pok√©mon n√£o encontrado!&quot;);
          } else {
            console.log(&quot;‚ö†Ô∏è Erro na API. C√≥digo:&quot;, resposta.status);
          }
          return;
        }
    
        const dados = await resposta.json();
    
        const nome: string = dados.name;
        const altura: number = dados.height / 10; // em metros
        const peso: number = dados.weight / 10;   // em kg
        const tipos: string = dados.types
          .map((tipo: any) =&gt; tipo.type.name)
          .join(&quot; / &quot;);
    
        console.log(`${capitalize(nome)} ‚Äì ${altura} m ‚Äì ${peso} kg ‚Äì ${tipos}`);
      } catch {
        console.log(&quot;‚ö†Ô∏è Erro de rede. Tente novamente.&quot;);
      }
    }
    </code></pre>
      <p>A fun√ß√£o <code>buscarPokemon</code> √© ass√≠ncrona (<code>async</code>) e retorna <code>void</code>. Ela faz a
        chamada √† API usando <code>fetch</code>, trata erros com <code>try/catch</code>, e formata os dados para
        exibi√ß√£o. √â importante notar que em JavaScript, opera√ß√µes ass√≠ncronas ‚Äî como chamadas de API, leitura de
        arquivos ou intera√ß√µes com banco de dados ‚Äî <strong>n√£o retornam imediatamente um valor</strong>, mas sim uma
        <strong>Promise</strong>, que representa um valor que <em>ainda n√£o est√° dispon√≠vel</em>, mas ser√° resolvido no
        futuro.</p>
      <p>Assim, a palavra-chave <code>async</code> transforma a fun√ß√£o <code>buscarPokemon</code> em uma fun√ß√£o
        ass√≠ncrona que sempre retorna uma <code>Promise</code>. O tipo <code>Promise&lt;void&gt;</code> indica que a
        fun√ß√£o <strong>n√£o retorna um valor √∫til</strong> (como <code>string</code> ou <code>number</code>), mas apenas
        finaliza seu trabalho de forma ass√≠ncrona.</p>
      <p>A grande vantagem de usar <code>async/await</code> √© a <strong>clareza do c√≥digo</strong>: podemos escrever
        chamadas ass√≠ncronas como se fossem s√≠ncronas, evitando encadeamentos confusos com <code>.then()</code> e
        <code>.catch()</code>. O uso de <code>await</code> <strong>pausa a execu√ß√£o da fun√ß√£o at√© que a Promise seja
          resolvida</strong>, permitindo trabalhar com os dados como se j√° estivessem dispon√≠veis ‚Äî o que √© muito √∫til
        em fun√ß√µes como <code>buscarPokemon</code>, onde cada etapa depende da anterior.</p>
      <p>J√° a linha seguinte, com <code>.map(...).join(&quot; / &quot;)</code>, demonstra a aplica√ß√£o de m√©todos de
        array em um contexto real para construir uma string de tipos do Pok√©mon (ex: <code>&quot;electric&quot;</code>
        ou <code>&quot;fire / flying&quot;</code>).</p>
      <h4>üìå Fun√ß√£o auxiliar <code>capitalize</code></h4>
      <pre><code class="language-ts">function capitalize(texto: string): string {
      return texto.charAt(0).toUpperCase() + texto.slice(1);
    }
    </code></pre>
      <p>Essa fun√ß√£o transforma a primeira letra da string em mai√∫scula ‚Äî exemplo de fun√ß√£o pura, reaproveit√°vel e
        tipada.</p>
      <h4>üìå Etapa 3 ‚Äì Execu√ß√£o</h4>
      <pre><code class="language-ts">buscarPokemon(entrada);
    </code></pre>
      <p>Com isso, iniciamos o programa passando o argumento capturado no terminal.</p>
      <h4>üß™ Exemplo de uso</h4>
      <pre><code class="language-bash">npx ts-node pokedex.ts pikachu
    </code></pre>
      <p>Sa√≠da esperada:</p>
      <pre><code>Pikachu ‚Äì 0.4 m ‚Äì 6 kg ‚Äì electric
    </code></pre>
      <h3>üßæ C√≥digo completo ‚Äì <code>pokedex.ts</code></h3>
      <pre><code class="language-ts">const entrada = process.argv[2];
    
    if (!entrada) {
      console.log(&quot;‚ùå Informe um nome ou ID de Pok√©mon.&quot;);
      process.exit(1);
    }
    
    function capitalize(texto: string): string {
      return texto.charAt(0).toUpperCase() + texto.slice(1);
    }
    
    async function buscarPokemon(idOuNome: string): Promise&lt;void&gt; {
      const url = `https://pokeapi.co/api/v2/pokemon/${idOuNome.toLowerCase()}`;
    
      try {
        const resposta = await fetch(url);
    
        if (!resposta.ok) {
          if (resposta.status === 404) {
            console.log(&quot;‚ùå Pok√©mon n√£o encontrado!&quot;);
          } else {
            console.log(&quot;‚ö†Ô∏è Erro na API. C√≥digo:&quot;, resposta.status);
          }
          return;
        }
    
        const dados = await resposta.json();
    
        const nome: string = dados.name;
        const altura: number = dados.height / 10;
        const peso: number = dados.weight / 10;
        const tipos: string = dados.types
          .map((tipo: any) =&gt; tipo.type.name)
          .join(&quot; / &quot;);
    
        console.log(`${capitalize(nome)} ‚Äì ${altura} m ‚Äì ${peso} kg ‚Äì ${tipos}`);
      } catch {
        console.log(&quot;‚ö†Ô∏è Erro de rede. Tente novamente.&quot;);
      }
    }
    
    buscarPokemon(entrada);
    </code></pre>
      <h4>‚úÖ Em s√≠ntese</h4>
      <p>Este exerc√≠cio reuniu v√°rios aspectos centrais da programa√ß√£o moderna com TypeScript:</p>
      <ul>
        <li>Uso de <strong>fun√ß√µes ass√≠ncronas (<code>async/await</code>)</strong></li>
        <li>Manipula√ß√£o de dados com <code>.map()</code> e <code>.join()</code> ‚Äî refor√ßando o paradigma funcional
          abordado na Se√ß√£o 1.7</li>
        <li>Tratamento de erros com <code>try/catch</code>, promovendo resili√™ncia do c√≥digo</li>
        <li>Tipagem expl√≠cita de vari√°veis, par√¢metros e retorno de fun√ß√µes</li>
        <li>Fun√ß√µes auxiliares puras (<code>capitalize</code>) para promover clareza e reutiliza√ß√£o</li>
      </ul>
      <p>Al√©m disso, introduzimos o uso de APIs p√∫blicas e da interface de linha de comando (CLI) ‚Äî temas muito
        presentes em projetos reais, inclusive para ferramentas internas ou utilit√°rios de integra√ß√£o.</p>
      <p>A essa altura, pode parecer que o desafio era grande para o momento em que ele foi proposto... e talvez fosse
        mesmo! üòÖ Mas acredito na capacidade de voc√™s, e a elabora√ß√£o de tarefas desafiadoras √© importante. Essa
        abordagem ‚Äî propondo antes e explicando depois ‚Äî ajuda a transformar a experi√™ncia pr√°tica (o famosos
        <em>quebrar a cabe√ßa</em>) em aprendizado consolidado.</p>
      <p>&quot;Ah, professor, mas eu n√£o consigo...&quot;</p>
      <p><strong>CONSEGUE SIM‚ÄºÔ∏è</strong> üó£Ô∏èüì¢</p>
      <hr>
      <h3>‚úÖ 4. Conclus√£o</h3>
      <p>Nesta aula, fizemos mais do que uma revis√£o de JavaScript moderno e uma introdu√ß√£o t√©cnica ao TypeScript ‚Äî
        <strong>preparamos o terreno para o desenvolvimento de aplica√ß√µes reais em React Native com seguran√ßa, clareza e
          produtividade</strong>.</p>
      <p>Cada recurso abordado tem um papel direto na pr√°tica que teremos a seguir:</p>
      <ul>
        <li><strong>O uso de <code>let</code> e <code>const</code></strong>, com escopo de bloco e previsibilidade, √©
          essencial para evitar efeitos colaterais indesejados na manipula√ß√£o de estado;</li>
        <li><strong>A desestrutura√ß√£o de arrays e objetos</strong> ser√° onipresente na intera√ß√£o com props, hooks e
          retornos de APIs;</li>
        <li><strong>Arrow functions</strong> s√£o padr√£o em handlers, callbacks e componentes funcionais ‚Äî e seu
          comportamento com <code>this</code> evita muitos erros silenciosos;</li>
        <li><strong>Template literals</strong> permitem compor strings din√¢micas para interfaces, mensagens e URLs de
          requisi√ß√£o de forma leg√≠vel e expressiva;</li>
        <li><strong>M√©todos como <code>map</code>, <code>filter</code> e <code>reduce</code></strong> ser√£o a base da
          renderiza√ß√£o de listas, filtragem de dados e constru√ß√£o de estados derivados;</li>
        <li><strong>A tipagem com TypeScript</strong>, incluindo tipos primitivos, interfaces, generics e utility types,
          <strong>n√£o √© um luxo, mas uma necessidade pr√°tica</strong> para prevenir erros e melhorar a comunica√ß√£o entre
          as partes do sistema;</li>
        <li>Finalmente, os exerc√≠cios propostos e resolvidos <strong>mostraram que podemos aplicar tudo isso em
            problemas reais</strong>, como criar utilit√°rios reutiliz√°veis, validar dados, e integrar com APIs.</li>
      </ul>
      <p>Em resumo: <strong>toda essa base te√≥rica e pr√°tica √© o alicerce do desenvolvimento com React Native</strong>.
        A partir da pr√≥xima aula, come√ßaremos a abordar o desenvolvimento mobile <em>de fato</em>. E faremos tudo isso
        de forma tipada, modular e segura ‚Äî exatamente porque dominamos os fundamentos revistos aqui.</p>
      <p>Se voc√™ achava que essa aula era s√≥ ‚Äúrevis√£o‚Äù... agora d√° pra ver que <strong>ela √© o pilar da nossa flu√™ncia
          no ecossistema mobile moderno</strong>. üöÄ</p>
      <p>Antes da pr√≥xima Aula, entretanto, sabem o que √© interessante para consolidar todo esse conhecimento?</p>
      <p>Sim, √© isso mesmo: exerc√≠cios!</p>
      <hr>
      <h2>5. Exerc√≠cios Propostos (TypeScript)</h2>
      <p>Os exerc√≠cios a seguir visam solidificar os principais conceitos de TypeScript abordados nesta aula:
        <strong>tipagem expl√≠cita</strong>, <strong>interfaces</strong>, <strong>tipos literais</strong>,
        <strong>uni√µes</strong>, <strong>generics</strong> e <strong>utility types</strong>. Vamos refor√ßar o que vimos
        pois utilizaremos posteriormente.</p>
      <p>Cada exerc√≠cio pode ser resolvido em um arquivo <code>.ts</code> pr√≥prio, e verificado com
        <code>npx tsc --noEmit</code> para valida√ß√£o sem gera√ß√£o de arquivos <code>.js</code>.</p>
      <p>Para entrega, envie um .ZIP ou link do reposit√≥rio no Moodle.</p>
      <h3>üîß Exerc√≠cio 1 ‚Äì Tipos, interfaces e m√©todos de array</h3>
      <p><strong>Objetivo:</strong> Tipar corretamente dados e fun√ß√µes que operam sobre listas.</p>
      <ol>
        <li>
          <p>Crie uma interface <code>Livro</code> com os campos:</p>
          <ul>
            <li><code>titulo</code> (string)</li>
            <li><code>autor</code> (string)</li>
            <li><code>ano</code> (number)</li>
            <li><code>disponivel</code> (boolean)</li>
          </ul>
        </li>
        <li>
          <p>Crie um array <code>biblioteca: Livro[]</code> com ao menos 3 livros.</p>
        </li>
        <li>
          <p>Implemente a fun√ß√£o <code>listarTitulosDisponiveis(livros: Livro[]): string[]</code>
            que retorne apenas os t√≠tulos dos livros com <code>disponivel = true</code>.</p>
        </li>
        <li>
          <p>Use <code>filter</code> e <code>map</code> com tipagem apropriada.</p>
        </li>
      </ol>
      <h3>üîß Exerc√≠cio 2 ‚Äì Tipos literais e uni√£o de tipos</h3>
      <p><strong>Objetivo:</strong> Representar m√∫ltiplos formatos poss√≠veis para um mesmo tipo de dado.</p>
      <ol>
        <li>Crie dois tipos:</li>
      </ol>
      <pre><code class="language-ts">type Sucesso = { tipo: &quot;sucesso&quot;; dados: string[] };
    type Erro = { tipo: &quot;erro&quot;; mensagem: string };
    type Resultado = Sucesso | Erro;
    </code></pre>
      <ol start="2">
        <li>Crie a fun√ß√£o <code>exibirResultado(r: Resultado): void</code> que:</li>
      </ol>
      <ul>
        <li>Mostra os dados se <code>r.tipo === &quot;sucesso&quot;</code></li>
        <li>Mostra a mensagem de erro se <code>r.tipo === &quot;erro&quot;</code></li>
      </ul>
      <ol start="3">
        <li>Use <code>if</code> com refinamento de tipo (type narrowing).</li>
      </ol>
      <h3>üîß Exerc√≠cio 3 ‚Äì Utility Types (<code>Omit</code>, <code>Partial</code>, <code>Readonly</code>)</h3>
      <p><strong>Objetivo:</strong> Criar varia√ß√µes seguras de tipos com base em estruturas existentes.</p>
      <ol>
        <li>
          <p>Crie uma interface <code>Usuario</code> com os campos:</p>
          <ul>
            <li><code>id: number</code></li>
            <li><code>nome: string</code></li>
            <li><code>email: string</code></li>
            <li><code>senha: string</code></li>
          </ul>
        </li>
        <li>
          <p>Crie dois novos tipos:</p>
        </li>
      </ol>
      <pre><code class="language-ts">type UsuarioSemSenha = Omit&lt;Usuario, &quot;senha&quot;&gt;;
    type UsuarioAtualizacao = Partial&lt;Usuario&gt;;
    </code></pre>
      <ol start="3">
        <li>Implemente duas fun√ß√µes:</li>
      </ol>
      <pre><code class="language-ts">function exibirPerfil(u: UsuarioSemSenha): void;
    function atualizarUsuario(id: number, dados: UsuarioAtualizacao): void;
    </code></pre>
      <p>Use <code>console.log()</code> para simular os efeitos.</p>
      <h3>üîß Exerc√≠cio 4 ‚Äì Fun√ß√µes gen√©ricas</h3>
      <p><strong>Objetivo:</strong> Criar fun√ß√µes reutiliz√°veis fortemente tipadas.</p>
      <ol>
        <li>
          <p>Implemente a fun√ß√£o <code>obterPrimeiro&lt;T&gt;(lista: T[]): T</code> que retorna o primeiro item da
            lista.</p>
        </li>
        <li>
          <p>Use a fun√ß√£o com uma lista de <code>string[]</code>, depois com <code>number[]</code>, e com um tipo
            personalizado:</p>
        </li>
      </ol>
      <pre><code class="language-ts">interface Produto {
      nome: string;
      preco: number;
    }
    </code></pre>
      <ol start="3">
        <li>Demonstre o uso correto da infer√™ncia de tipos.</li>
      </ol>
      <h3>üîß Exerc√≠cio 5 ‚Äì Tipagem em componentes e props</h3>
      <p><strong>Objetivo:</strong> Simular props de componentes com TypeScript.</p>
      <ol>
        <li>
          <p>Crie uma interface <code>PropsBotao</code> com:</p>
          <ul>
            <li><code>titulo: string</code></li>
            <li><code>ativo?: boolean</code></li>
          </ul>
        </li>
        <li>
          <p>Implemente a fun√ß√£o:</p>
        </li>
      </ol>
      <pre><code class="language-ts">function renderizarBotao({ titulo, ativo = true }: PropsBotao): string {
      return ativo ? `[ ${titulo} ]` : `( ${titulo} )`;
    }
    </code></pre>
      <ol start="3">
        <li>Teste com diferentes valores.</li>
      </ol>
      <h3>‚úÖ Dica: valida√ß√£o com o TypeScript</h3>
      <p>Use o comando abaixo para validar os exerc√≠cios sem gerar arquivos <code>.js</code>:</p>
      <pre><code class="language-bash">npx tsc --noEmit
    </code></pre>

    </div>

  </div>


  <footer class="footer mt-auto py-3">
    <div class="container-fluid">
      <span>
        <p class="text-center text-light">Instituto Federal de Educa√ß√£o, Ci√™ncia e Tecnologia de S√£o Paulo,
          C√¢mpus Guarulhos. Desenvolvimento Mobile - Prof. Giovani.</p>
      </span>
    </div>
  </footer>


  <script src="js/prism.js"></script>
  <script src="js/jquery.min.js"></script>
  <script src="js/popper.js"></script>
  <script src="js/bootstrap.min.js"></script>
  <script src="js/main.js"></script>

</body>

</html>