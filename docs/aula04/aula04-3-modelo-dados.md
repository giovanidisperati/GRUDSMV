---
layout: aula
title: 3. Um pouquinho sobre Cria√ß√£o e valida√ß√£o de Modelos de Dados
parent: Aula 04 - Spring Boot - JPA, Exce√ß√µes e Documenta√ß√£o!
nav_order: 3
---

## **3.üîç Criando e validando modelos de Dados**

Para continuarmos a abordar os conceitos do desenvolvimento de APIS Rest com Spring Boot, relembremos os Desafios 1 e 2 da Aula 03.

O Desafio 1 tinha como objetivo criar uma nova entidade `Address` relacionada bidirecionalmente com `Contact`, implementar um reposit√≥rio `AddressRepository` e criar um controlador `AddressController` para gerenciar endere√ßos. Tamb√©m era necess√°rio criar um endpoint `GET /api/contacts/{id}/addresses` para listar todos os endere√ßos associados a um contato espec√≠fico.

J√° o Desafio 2 exigia a adi√ß√£o de valida√ß√µes na entidade `Contact` utilizando a anota√ß√£o `@Valid`. As regras incluem: nome n√£o pode estar vazio, email deve ter um formato v√°lido (`@Email`) e telefone deve ter entre 8 e 15 caracteres. A API deve retornar respostas adequadas para entradas inv√°lidas.

Para facilitar a explica√ß√£o e evitar repeti√ß√£o desnecess√°rio, vamos implementar c√≥digo que atenda ambos os desafios. Para conseguir implementar esses desafios, entretanto, temos que entender dois conceitos fundamentais: relacionamento entre Entidades com uso da JPA e a Valida√ß√£o de dados com a `Jakarta Bean Validation`.

### **3.1 Uma breve introdu√ß√£o ao relacionamento entre Entidades**

Relacionamentos de entidades na JPA s√£o fundamentais para representar como os dados interagem entre si no banco de dados. A JPA (Java Persistence API) fornece suporte para mapeamento de associa√ß√µes entre entidades usando anota√ß√µes espec√≠ficas que permitem definir os tipos de relacionamento que podem ocorrer entre essas entidades. Os relacionamentos mais comuns s√£o OneToOne, OneToMany, ManyToOne e ManyToMany. Quando mapeamos uma rela√ß√£o **OneToOne**, indicamos que uma entidade est√° associada exclusivamente a outra entidade. Para isso, utilizamos a anota√ß√£o `@OneToOne`, que pode ser configurada com o atributo `mappedBy` para especificar o lado propriet√°rio da rela√ß√£o.

No relacionamento **ManyToOne**, uma entidade pode estar associada a v√°rias inst√¢ncias de outra entidade, mas a rela√ß√£o inversa geralmente √© **OneToMany**, ou seja, um √∫nico objeto de uma entidade pode ter v√°rias refer√™ncias de outra entidade. Por exemplo, em uma aplica√ß√£o de contatos e endere√ßos, cada endere√ßo est√° associado a um √∫nico contato, mas um contato pode ter m√∫ltiplos endere√ßos. Isso √© representado na JPA com `@ManyToOne` na classe `Address` e `@OneToMany` na classe `Contact`. Al√©m disso, √© necess√°rio configurar adequadamente as anota√ß√µes `@JoinColumn` para definir a chave estrangeira que conecta as tabelas.

O relacionamento **ManyToMany** √© usado quando m√∫ltiplas inst√¢ncias de uma entidade podem estar associadas a m√∫ltiplas inst√¢ncias de outra. Esse tipo de relacionamento geralmente √© mapeado por meio de uma tabela intermedi√°ria que cont√©m as chaves estrangeiras de ambas as entidades relacionadas. Na JPA, usamos a anota√ß√£o `@ManyToMany` para definir esse tipo de relacionamento, e podemos usar a propriedade `mappedBy` para especificar o lado n√£o propriet√°rio da associa√ß√£o.

√â importante entender que os relacionamentos na JPA podem ser configurados para serem unidirecionais ou bidirecionais. Uma associa√ß√£o unidirecional significa que apenas uma entidade conhece a exist√™ncia da outra, enquanto uma associa√ß√£o bidirecional permite que ambas as entidades se conhe√ßam mutuamente, o que √© √∫til quando queremos acessar dados relacionados de forma mais natural e eficiente. Quando implementamos um relacionamento bidirecional, precisamos garantir que a sincroniza√ß√£o entre os dois lados do relacionamento seja tratada adequadamente. Isso √© feito configurando o atributo `mappedBy` no lado que n√£o √© o propriet√°rio da rela√ß√£o, informando √† JPA qual entidade √© respons√°vel pelo gerenciamento do relacionamento.

Al√©m disso, ao configurar relacionamentos, √© fundamental definir adequadamente o comportamento de **cascade** e **orphanRemoval**, que especificam se opera√ß√µes realizadas em uma entidade principal devem ser propagadas para as entidades relacionadas. Por exemplo, ao excluir um contato, podemos querer que todos os endere√ßos associados tamb√©m sejam removidos automaticamente, o que √© configurado com o uso da propriedade `cascade = CascadeType.ALL` e `orphanRemoval = true` na anota√ß√£o `@OneToMany`.

### **3.2 Valida√ß√£o de dados de forma simplificada**

A valida√ß√£o de dados √© um processo essencial para garantir que as informa√ß√µes fornecidas por usu√°rios ou sistemas externos sejam corretas, seguras e adequadas antes de serem processadas ou armazenadas. A linguagem Java fornece v√°rias maneiras de realizar valida√ß√µes, mas a abordagem mais comum e eficiente √© por meio das anota√ß√µes de valida√ß√£o fornecidas pelo pacote **Jakarta Bean Validation** (anteriormente conhecido como Java EE Bean Validation) e integrado ao Spring Framework por meio da biblioteca **Hibernate Validator**. Esse mecanismo oferece uma maneira declarativa e robusta para validar dados de entrada sem necessidade de escrever c√≥digo complexo para cada regra de valida√ß√£o.

O Jakarta Bean Validation utiliza anota√ß√µes que s√£o aplicadas diretamente sobre os atributos das classes, facilitando o processo de valida√ß√£o e mantendo o c√≥digo organizado e leg√≠vel. As anota√ß√µes mais comuns incluem `@NotNull`, que garante que o valor de um campo n√£o pode ser nulo; `@NotBlank`, que assegura que um campo de texto n√£o √© vazio ou apenas cont√©m espa√ßos em branco; `@Size`, que define o tamanho m√≠nimo e m√°ximo permitido para uma string ou cole√ß√£o; `@Pattern`, que permite especificar uma express√£o regular para valida√ß√£o de formato; e `@Email`, que verifica se um dado fornecido corresponde a um formato v√°lido de endere√ßo de e-mail. Al√©m dessas, existem v√°rias outras anota√ß√µes espec√≠ficas que podem ser usadas dependendo das necessidades da aplica√ß√£o, podendo ser consultadas em [Hibernate Validator - Defini√ß√£o de Restri√ß√µes (Documenta√ß√£o Oficial)](https://docs.jboss.org/hibernate/stable/validator/reference/en-US/html_single/#validator-defineconstraints-spec)

A configura√ß√£o da valida√ß√£o no Spring Boot √© bastante simples e, geralmente, basta adicionar a depend√™ncia do `Hibernate Validator` no arquivo `pom.xml` do projeto. 

Ao longo da disciplina vamos, evidentemente, utilizar as valida√ß√µes para o desenvolvimento de APIs com o Spring Boot. Nesse contexto, o uso da anota√ß√£o `@Valid` nos controladores REST √© fundamental para ativar o mecanismo de valida√ß√£o autom√°tica dos dados recebidos. Quando um cliente envia dados para o servidor, o Spring automaticamente verifica se os dados atendem aos crit√©rios estabelecidos pelas anota√ß√µes de valida√ß√£o na entidade ou no DTO (Data Transfer Object, padr√£o que abordaremos nas pr√≥ximas aulas) e, caso algum crit√©rio n√£o seja satisfeito, uma exce√ß√£o √© lan√ßada, normalmente a `MethodArgumentNotValidException`. Essa exce√ß√£o precisa ser tratada por um mecanismo de tratamento de erros personalizado, como o `GlobalExceptionHandler` que implementamos anteriormente, para que a aplica√ß√£o possa responder de forma adequada e amig√°vel ao cliente, geralmente retornando um c√≥digo de status HTTP 400 (Bad Request) junto com uma mensagem explicativa. Ou seja, a partir da√≠ basta aplicar as anota√ß√µes necess√°rias nos atributos das entidades ou DTOs e n√£o se esquecer utilizar o `@Valid` nos m√©todos controladores. Al√©m disso, o Spring Boot permite definir mensagens de erro personalizadas para cada tipo de valida√ß√£o, tornando as respostas da API mais claras e amig√°veis para os consumidores do servi√ßo.

Al√©m das valida√ß√µes padr√£o fornecidas pela especifica√ß√£o Jakarta Bean Validation, √© poss√≠vel definir valida√ß√µes personalizadas quando os requisitos do sistema s√£o mais espec√≠ficos. Para isso, criamos uma anota√ß√£o customizada e implementamos um validador que implementa a interface `ConstraintValidator`. Esse mecanismo permite que os desenvolvedores criem suas pr√≥prias regras de valida√ß√£o e as apliquem a campos ou classes inteiras, mantendo a flexibilidade e a escalabilidade da aplica√ß√£o. Futuramente exploraremos essa possibilidade na disciplina.

√â importante destacar que a valida√ß√£o de dados deve ser realizada tanto no lado do cliente quanto no lado do servidor. Embora bibliotecas de frontend como React e Angular forne√ßam recursos para valida√ß√£o de formul√°rios, a valida√ß√£o no servidor √© indispens√°vel para garantir a seguran√ßa e integridade dos dados, pois os clientes podem ser manipulados ou burlados por usu√°rios mal-intencionados. Por isso, as valida√ß√µes feitas no servidor s√£o a principal linha de defesa contra dados inv√°lidos ou maliciosos. **Lembrem-se: temos controle real apenas sobre o lado do servidor. O lado cliente √© do cliente!**

Vamos agora verificar o c√≥digo que implementa os Desafios 1 e 2 da Aula 03.